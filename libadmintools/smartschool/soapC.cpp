/* soapC.cpp
   Generated by gSOAP 2.8.17r from interface.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2017-04-29 06:17:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__returnJsonErrorCodes:
		return soap_in_ns1__returnJsonErrorCodes(soap, NULL, NULL, "ns1:returnJsonErrorCodes");
	case SOAP_TYPE_ns1__returnJsonErrorCodesResponse:
		return soap_in_ns1__returnJsonErrorCodesResponse(soap, NULL, NULL, "ns1:returnJsonErrorCodesResponse");
	case SOAP_TYPE_ns1__returnCsvErrorCodes:
		return soap_in_ns1__returnCsvErrorCodes(soap, NULL, NULL, "ns1:returnCsvErrorCodes");
	case SOAP_TYPE_ns1__returnCsvErrorCodesResponse:
		return soap_in_ns1__returnCsvErrorCodesResponse(soap, NULL, NULL, "ns1:returnCsvErrorCodesResponse");
	case SOAP_TYPE_ns1__returnErrorCodes:
		return soap_in_ns1__returnErrorCodes(soap, NULL, NULL, "ns1:returnErrorCodes");
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthentication:
		return soap_in_ns1__deactivateTwoFactorAuthentication(soap, NULL, NULL, "ns1:deactivateTwoFactorAuthentication");
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse:
		return soap_in_ns1__deactivateTwoFactorAuthenticationResponse(soap, NULL, NULL, "ns1:deactivateTwoFactorAuthenticationResponse");
	case SOAP_TYPE_ns1__getStudentCareer:
		return soap_in_ns1__getStudentCareer(soap, NULL, NULL, "ns1:getStudentCareer");
	case SOAP_TYPE_ns1__getStudentCareerResponse:
		return soap_in_ns1__getStudentCareerResponse(soap, NULL, NULL, "ns1:getStudentCareerResponse");
	case SOAP_TYPE_ns1__saveSignature:
		return soap_in_ns1__saveSignature(soap, NULL, NULL, "ns1:saveSignature");
	case SOAP_TYPE_ns1__saveSignatureResponse:
		return soap_in_ns1__saveSignatureResponse(soap, NULL, NULL, "ns1:saveSignatureResponse");
	case SOAP_TYPE_ns1__getUserOfficialClass:
		return soap_in_ns1__getUserOfficialClass(soap, NULL, NULL, "ns1:getUserOfficialClass");
	case SOAP_TYPE_ns1__getUserOfficialClassResponse:
		return soap_in_ns1__getUserOfficialClassResponse(soap, NULL, NULL, "ns1:getUserOfficialClassResponse");
	case SOAP_TYPE_ns1__getUserDetailsByUsername:
		return soap_in_ns1__getUserDetailsByUsername(soap, NULL, NULL, "ns1:getUserDetailsByUsername");
	case SOAP_TYPE_ns1__getUserDetailsByUsernameResponse:
		return soap_in_ns1__getUserDetailsByUsernameResponse(soap, NULL, NULL, "ns1:getUserDetailsByUsernameResponse");
	case SOAP_TYPE_ns1__getUserDetailsByNumber:
		return soap_in_ns1__getUserDetailsByNumber(soap, NULL, NULL, "ns1:getUserDetailsByNumber");
	case SOAP_TYPE_ns1__getUserDetailsByNumberResponse:
		return soap_in_ns1__getUserDetailsByNumberResponse(soap, NULL, NULL, "ns1:getUserDetailsByNumberResponse");
	case SOAP_TYPE_ns1__getUserDetails:
		return soap_in_ns1__getUserDetails(soap, NULL, NULL, "ns1:getUserDetails");
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return soap_in_ns1__getUserDetailsResponse(soap, NULL, NULL, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_ns1__getAbsents:
		return soap_in_ns1__getAbsents(soap, NULL, NULL, "ns1:getAbsents");
	case SOAP_TYPE_ns1__getAbsentsResponse:
		return soap_in_ns1__getAbsentsResponse(soap, NULL, NULL, "ns1:getAbsentsResponse");
	case SOAP_TYPE_ns1__getAbsentsByDate:
		return soap_in_ns1__getAbsentsByDate(soap, NULL, NULL, "ns1:getAbsentsByDate");
	case SOAP_TYPE_ns1__getAbsentsByDateResponse:
		return soap_in_ns1__getAbsentsByDateResponse(soap, NULL, NULL, "ns1:getAbsentsByDateResponse");
	case SOAP_TYPE_ns1__getClassTeachers:
		return soap_in_ns1__getClassTeachers(soap, NULL, NULL, "ns1:getClassTeachers");
	case SOAP_TYPE_ns1__getClassTeachersResponse:
		return soap_in_ns1__getClassTeachersResponse(soap, NULL, NULL, "ns1:getClassTeachersResponse");
	case SOAP_TYPE_ns1__unregisterStudent:
		return soap_in_ns1__unregisterStudent(soap, NULL, NULL, "ns1:unregisterStudent");
	case SOAP_TYPE_ns1__unregisterStudentResponse:
		return soap_in_ns1__unregisterStudentResponse(soap, NULL, NULL, "ns1:unregisterStudentResponse");
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation:
		return soap_in_ns1__getSkoreClassTeacherCourseRelation(soap, NULL, NULL, "ns1:getSkoreClassTeacherCourseRelation");
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse:
		return soap_in_ns1__getSkoreClassTeacherCourseRelationResponse(soap, NULL, NULL, "ns1:getSkoreClassTeacherCourseRelationResponse");
	case SOAP_TYPE_ns1__sendMsg:
		return soap_in_ns1__sendMsg(soap, NULL, NULL, "ns1:sendMsg");
	case SOAP_TYPE_ns1__sendMsgResponse:
		return soap_in_ns1__sendMsgResponse(soap, NULL, NULL, "ns1:sendMsgResponse");
	case SOAP_TYPE_ns1__savePassword:
		return soap_in_ns1__savePassword(soap, NULL, NULL, "ns1:savePassword");
	case SOAP_TYPE_ns1__savePasswordResponse:
		return soap_in_ns1__savePasswordResponse(soap, NULL, NULL, "ns1:savePasswordResponse");
	case SOAP_TYPE_ns1__forcePasswordReset:
		return soap_in_ns1__forcePasswordReset(soap, NULL, NULL, "ns1:forcePasswordReset");
	case SOAP_TYPE_ns1__forcePasswordResetResponse:
		return soap_in_ns1__forcePasswordResetResponse(soap, NULL, NULL, "ns1:forcePasswordResetResponse");
	case SOAP_TYPE_ns1__replaceInum:
		return soap_in_ns1__replaceInum(soap, NULL, NULL, "ns1:replaceInum");
	case SOAP_TYPE_ns1__replaceInumResponse:
		return soap_in_ns1__replaceInumResponse(soap, NULL, NULL, "ns1:replaceInumResponse");
	case SOAP_TYPE_ns1__getAccountPhoto:
		return soap_in_ns1__getAccountPhoto(soap, NULL, NULL, "ns1:getAccountPhoto");
	case SOAP_TYPE_ns1__getAccountPhotoResponse:
		return soap_in_ns1__getAccountPhotoResponse(soap, NULL, NULL, "ns1:getAccountPhotoResponse");
	case SOAP_TYPE_ns1__setAccountPhoto:
		return soap_in_ns1__setAccountPhoto(soap, NULL, NULL, "ns1:setAccountPhoto");
	case SOAP_TYPE_ns1__setAccountPhotoResponse:
		return soap_in_ns1__setAccountPhotoResponse(soap, NULL, NULL, "ns1:setAccountPhotoResponse");
	case SOAP_TYPE_ns1__setAccountStatus:
		return soap_in_ns1__setAccountStatus(soap, NULL, NULL, "ns1:setAccountStatus");
	case SOAP_TYPE_ns1__setAccountStatusResponse:
		return soap_in_ns1__setAccountStatusResponse(soap, NULL, NULL, "ns1:setAccountStatusResponse");
	case SOAP_TYPE_ns1__saveUserToClassesAndGroups:
		return soap_in_ns1__saveUserToClassesAndGroups(soap, NULL, NULL, "ns1:saveUserToClassesAndGroups");
	case SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse:
		return soap_in_ns1__saveUserToClassesAndGroupsResponse(soap, NULL, NULL, "ns1:saveUserToClassesAndGroupsResponse");
	case SOAP_TYPE_ns1__saveUserToClass:
		return soap_in_ns1__saveUserToClass(soap, NULL, NULL, "ns1:saveUserToClass");
	case SOAP_TYPE_ns1__saveUserToClassResponse:
		return soap_in_ns1__saveUserToClassResponse(soap, NULL, NULL, "ns1:saveUserToClassResponse");
	case SOAP_TYPE_ns1__removeUserFromGroup:
		return soap_in_ns1__removeUserFromGroup(soap, NULL, NULL, "ns1:removeUserFromGroup");
	case SOAP_TYPE_ns1__removeUserFromGroupResponse:
		return soap_in_ns1__removeUserFromGroupResponse(soap, NULL, NULL, "ns1:removeUserFromGroupResponse");
	case SOAP_TYPE_ns1__saveUserToClasses:
		return soap_in_ns1__saveUserToClasses(soap, NULL, NULL, "ns1:saveUserToClasses");
	case SOAP_TYPE_ns1__saveUserToClassesResponse:
		return soap_in_ns1__saveUserToClassesResponse(soap, NULL, NULL, "ns1:saveUserToClassesResponse");
	case SOAP_TYPE_ns1__delClass:
		return soap_in_ns1__delClass(soap, NULL, NULL, "ns1:delClass");
	case SOAP_TYPE_ns1__delClassResponse:
		return soap_in_ns1__delClassResponse(soap, NULL, NULL, "ns1:delClassResponse");
	case SOAP_TYPE_ns1__saveClassListJson:
		return soap_in_ns1__saveClassListJson(soap, NULL, NULL, "ns1:saveClassListJson");
	case SOAP_TYPE_ns1__saveClassListJsonResponse:
		return soap_in_ns1__saveClassListJsonResponse(soap, NULL, NULL, "ns1:saveClassListJsonResponse");
	case SOAP_TYPE_ns1__saveClassList:
		return soap_in_ns1__saveClassList(soap, NULL, NULL, "ns1:saveClassList");
	case SOAP_TYPE_ns1__saveClassListResponse:
		return soap_in_ns1__saveClassListResponse(soap, NULL, NULL, "ns1:saveClassListResponse");
	case SOAP_TYPE_ns1__getClassListJson:
		return soap_in_ns1__getClassListJson(soap, NULL, NULL, "ns1:getClassListJson");
	case SOAP_TYPE_ns1__getClassListJsonResponse:
		return soap_in_ns1__getClassListJsonResponse(soap, NULL, NULL, "ns1:getClassListJsonResponse");
	case SOAP_TYPE_ns1__getClassList:
		return soap_in_ns1__getClassList(soap, NULL, NULL, "ns1:getClassList");
	case SOAP_TYPE_ns1__getClassListResponse:
		return soap_in_ns1__getClassListResponse(soap, NULL, NULL, "ns1:getClassListResponse");
	case SOAP_TYPE_ns1__saveUserParameter:
		return soap_in_ns1__saveUserParameter(soap, NULL, NULL, "ns1:saveUserParameter");
	case SOAP_TYPE_ns1__saveUserParameterResponse:
		return soap_in_ns1__saveUserParameterResponse(soap, NULL, NULL, "ns1:saveUserParameterResponse");
	case SOAP_TYPE_ns1__delUser:
		return soap_in_ns1__delUser(soap, NULL, NULL, "ns1:delUser");
	case SOAP_TYPE_ns1__delUserResponse:
		return soap_in_ns1__delUserResponse(soap, NULL, NULL, "ns1:delUserResponse");
	case SOAP_TYPE_ns1__getCourses:
		return soap_in_ns1__getCourses(soap, NULL, NULL, "ns1:getCourses");
	case SOAP_TYPE_ns1__getCoursesResponse:
		return soap_in_ns1__getCoursesResponse(soap, NULL, NULL, "ns1:getCoursesResponse");
	case SOAP_TYPE_ns1__addCourseStudents:
		return soap_in_ns1__addCourseStudents(soap, NULL, NULL, "ns1:addCourseStudents");
	case SOAP_TYPE_ns1__addCourseStudentsResponse:
		return soap_in_ns1__addCourseStudentsResponse(soap, NULL, NULL, "ns1:addCourseStudentsResponse");
	case SOAP_TYPE_ns1__addCourseTeacher:
		return soap_in_ns1__addCourseTeacher(soap, NULL, NULL, "ns1:addCourseTeacher");
	case SOAP_TYPE_ns1__addCourseTeacherResponse:
		return soap_in_ns1__addCourseTeacherResponse(soap, NULL, NULL, "ns1:addCourseTeacherResponse");
	case SOAP_TYPE_ns1__addCourse:
		return soap_in_ns1__addCourse(soap, NULL, NULL, "ns1:addCourse");
	case SOAP_TYPE_ns1__addCourseResponse:
		return soap_in_ns1__addCourseResponse(soap, NULL, NULL, "ns1:addCourseResponse");
	case SOAP_TYPE_ns1__getAllGroupsAndClasses:
		return soap_in_ns1__getAllGroupsAndClasses(soap, NULL, NULL, "ns1:getAllGroupsAndClasses");
	case SOAP_TYPE_ns1__getAllGroupsAndClassesResponse:
		return soap_in_ns1__getAllGroupsAndClassesResponse(soap, NULL, NULL, "ns1:getAllGroupsAndClassesResponse");
	case SOAP_TYPE_ns1__getAllAccountsExtended:
		return soap_in_ns1__getAllAccountsExtended(soap, NULL, NULL, "ns1:getAllAccountsExtended");
	case SOAP_TYPE_ns1__getAllAccountsExtendedResponse:
		return soap_in_ns1__getAllAccountsExtendedResponse(soap, NULL, NULL, "ns1:getAllAccountsExtendedResponse");
	case SOAP_TYPE_ns1__getAllAccounts:
		return soap_in_ns1__getAllAccounts(soap, NULL, NULL, "ns1:getAllAccounts");
	case SOAP_TYPE_ns1__getAllAccountsResponse:
		return soap_in_ns1__getAllAccountsResponse(soap, NULL, NULL, "ns1:getAllAccountsResponse");
	case SOAP_TYPE_ns1__saveGroup:
		return soap_in_ns1__saveGroup(soap, NULL, NULL, "ns1:saveGroup");
	case SOAP_TYPE_ns1__saveGroupResponse:
		return soap_in_ns1__saveGroupResponse(soap, NULL, NULL, "ns1:saveGroupResponse");
	case SOAP_TYPE_ns1__saveClass:
		return soap_in_ns1__saveClass(soap, NULL, NULL, "ns1:saveClass");
	case SOAP_TYPE_ns1__saveClassResponse:
		return soap_in_ns1__saveClassResponse(soap, NULL, NULL, "ns1:saveClassResponse");
	case SOAP_TYPE_ns1__saveUser:
		return soap_in_ns1__saveUser(soap, NULL, NULL, "ns1:saveUser");
	case SOAP_TYPE_ns1__saveUserResponse:
		return soap_in_ns1__saveUserResponse(soap, NULL, NULL, "ns1:saveUserResponse");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnJsonErrorCodes"))
		{	*type = SOAP_TYPE_ns1__returnJsonErrorCodes;
			return soap_in_ns1__returnJsonErrorCodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnJsonErrorCodesResponse"))
		{	*type = SOAP_TYPE_ns1__returnJsonErrorCodesResponse;
			return soap_in_ns1__returnJsonErrorCodesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnCsvErrorCodes"))
		{	*type = SOAP_TYPE_ns1__returnCsvErrorCodes;
			return soap_in_ns1__returnCsvErrorCodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnCsvErrorCodesResponse"))
		{	*type = SOAP_TYPE_ns1__returnCsvErrorCodesResponse;
			return soap_in_ns1__returnCsvErrorCodesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:returnErrorCodes"))
		{	*type = SOAP_TYPE_ns1__returnErrorCodes;
			return soap_in_ns1__returnErrorCodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deactivateTwoFactorAuthentication"))
		{	*type = SOAP_TYPE_ns1__deactivateTwoFactorAuthentication;
			return soap_in_ns1__deactivateTwoFactorAuthentication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deactivateTwoFactorAuthenticationResponse"))
		{	*type = SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse;
			return soap_in_ns1__deactivateTwoFactorAuthenticationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStudentCareer"))
		{	*type = SOAP_TYPE_ns1__getStudentCareer;
			return soap_in_ns1__getStudentCareer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStudentCareerResponse"))
		{	*type = SOAP_TYPE_ns1__getStudentCareerResponse;
			return soap_in_ns1__getStudentCareerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveSignature"))
		{	*type = SOAP_TYPE_ns1__saveSignature;
			return soap_in_ns1__saveSignature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveSignatureResponse"))
		{	*type = SOAP_TYPE_ns1__saveSignatureResponse;
			return soap_in_ns1__saveSignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserOfficialClass"))
		{	*type = SOAP_TYPE_ns1__getUserOfficialClass;
			return soap_in_ns1__getUserOfficialClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserOfficialClassResponse"))
		{	*type = SOAP_TYPE_ns1__getUserOfficialClassResponse;
			return soap_in_ns1__getUserOfficialClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsByUsername"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsByUsername;
			return soap_in_ns1__getUserDetailsByUsername(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsByUsernameResponse"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsByUsernameResponse;
			return soap_in_ns1__getUserDetailsByUsernameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsByNumber"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsByNumber;
			return soap_in_ns1__getUserDetailsByNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsByNumberResponse"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsByNumberResponse;
			return soap_in_ns1__getUserDetailsByNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetails"))
		{	*type = SOAP_TYPE_ns1__getUserDetails;
			return soap_in_ns1__getUserDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDetailsResponse"))
		{	*type = SOAP_TYPE_ns1__getUserDetailsResponse;
			return soap_in_ns1__getUserDetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAbsents"))
		{	*type = SOAP_TYPE_ns1__getAbsents;
			return soap_in_ns1__getAbsents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAbsentsResponse"))
		{	*type = SOAP_TYPE_ns1__getAbsentsResponse;
			return soap_in_ns1__getAbsentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAbsentsByDate"))
		{	*type = SOAP_TYPE_ns1__getAbsentsByDate;
			return soap_in_ns1__getAbsentsByDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAbsentsByDateResponse"))
		{	*type = SOAP_TYPE_ns1__getAbsentsByDateResponse;
			return soap_in_ns1__getAbsentsByDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassTeachers"))
		{	*type = SOAP_TYPE_ns1__getClassTeachers;
			return soap_in_ns1__getClassTeachers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassTeachersResponse"))
		{	*type = SOAP_TYPE_ns1__getClassTeachersResponse;
			return soap_in_ns1__getClassTeachersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unregisterStudent"))
		{	*type = SOAP_TYPE_ns1__unregisterStudent;
			return soap_in_ns1__unregisterStudent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unregisterStudentResponse"))
		{	*type = SOAP_TYPE_ns1__unregisterStudentResponse;
			return soap_in_ns1__unregisterStudentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSkoreClassTeacherCourseRelation"))
		{	*type = SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation;
			return soap_in_ns1__getSkoreClassTeacherCourseRelation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSkoreClassTeacherCourseRelationResponse"))
		{	*type = SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse;
			return soap_in_ns1__getSkoreClassTeacherCourseRelationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendMsg"))
		{	*type = SOAP_TYPE_ns1__sendMsg;
			return soap_in_ns1__sendMsg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendMsgResponse"))
		{	*type = SOAP_TYPE_ns1__sendMsgResponse;
			return soap_in_ns1__sendMsgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:savePassword"))
		{	*type = SOAP_TYPE_ns1__savePassword;
			return soap_in_ns1__savePassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:savePasswordResponse"))
		{	*type = SOAP_TYPE_ns1__savePasswordResponse;
			return soap_in_ns1__savePasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:forcePasswordReset"))
		{	*type = SOAP_TYPE_ns1__forcePasswordReset;
			return soap_in_ns1__forcePasswordReset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:forcePasswordResetResponse"))
		{	*type = SOAP_TYPE_ns1__forcePasswordResetResponse;
			return soap_in_ns1__forcePasswordResetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:replaceInum"))
		{	*type = SOAP_TYPE_ns1__replaceInum;
			return soap_in_ns1__replaceInum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:replaceInumResponse"))
		{	*type = SOAP_TYPE_ns1__replaceInumResponse;
			return soap_in_ns1__replaceInumResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountPhoto"))
		{	*type = SOAP_TYPE_ns1__getAccountPhoto;
			return soap_in_ns1__getAccountPhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountPhotoResponse"))
		{	*type = SOAP_TYPE_ns1__getAccountPhotoResponse;
			return soap_in_ns1__getAccountPhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAccountPhoto"))
		{	*type = SOAP_TYPE_ns1__setAccountPhoto;
			return soap_in_ns1__setAccountPhoto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAccountPhotoResponse"))
		{	*type = SOAP_TYPE_ns1__setAccountPhotoResponse;
			return soap_in_ns1__setAccountPhotoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAccountStatus"))
		{	*type = SOAP_TYPE_ns1__setAccountStatus;
			return soap_in_ns1__setAccountStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAccountStatusResponse"))
		{	*type = SOAP_TYPE_ns1__setAccountStatusResponse;
			return soap_in_ns1__setAccountStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClassesAndGroups"))
		{	*type = SOAP_TYPE_ns1__saveUserToClassesAndGroups;
			return soap_in_ns1__saveUserToClassesAndGroups(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClassesAndGroupsResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse;
			return soap_in_ns1__saveUserToClassesAndGroupsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClass"))
		{	*type = SOAP_TYPE_ns1__saveUserToClass;
			return soap_in_ns1__saveUserToClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClassResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserToClassResponse;
			return soap_in_ns1__saveUserToClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeUserFromGroup"))
		{	*type = SOAP_TYPE_ns1__removeUserFromGroup;
			return soap_in_ns1__removeUserFromGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeUserFromGroupResponse"))
		{	*type = SOAP_TYPE_ns1__removeUserFromGroupResponse;
			return soap_in_ns1__removeUserFromGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClasses"))
		{	*type = SOAP_TYPE_ns1__saveUserToClasses;
			return soap_in_ns1__saveUserToClasses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserToClassesResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserToClassesResponse;
			return soap_in_ns1__saveUserToClassesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delClass"))
		{	*type = SOAP_TYPE_ns1__delClass;
			return soap_in_ns1__delClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delClassResponse"))
		{	*type = SOAP_TYPE_ns1__delClassResponse;
			return soap_in_ns1__delClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClassListJson"))
		{	*type = SOAP_TYPE_ns1__saveClassListJson;
			return soap_in_ns1__saveClassListJson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClassListJsonResponse"))
		{	*type = SOAP_TYPE_ns1__saveClassListJsonResponse;
			return soap_in_ns1__saveClassListJsonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClassList"))
		{	*type = SOAP_TYPE_ns1__saveClassList;
			return soap_in_ns1__saveClassList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClassListResponse"))
		{	*type = SOAP_TYPE_ns1__saveClassListResponse;
			return soap_in_ns1__saveClassListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassListJson"))
		{	*type = SOAP_TYPE_ns1__getClassListJson;
			return soap_in_ns1__getClassListJson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassListJsonResponse"))
		{	*type = SOAP_TYPE_ns1__getClassListJsonResponse;
			return soap_in_ns1__getClassListJsonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassList"))
		{	*type = SOAP_TYPE_ns1__getClassList;
			return soap_in_ns1__getClassList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getClassListResponse"))
		{	*type = SOAP_TYPE_ns1__getClassListResponse;
			return soap_in_ns1__getClassListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserParameter"))
		{	*type = SOAP_TYPE_ns1__saveUserParameter;
			return soap_in_ns1__saveUserParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserParameterResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserParameterResponse;
			return soap_in_ns1__saveUserParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delUser"))
		{	*type = SOAP_TYPE_ns1__delUser;
			return soap_in_ns1__delUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delUserResponse"))
		{	*type = SOAP_TYPE_ns1__delUserResponse;
			return soap_in_ns1__delUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCourses"))
		{	*type = SOAP_TYPE_ns1__getCourses;
			return soap_in_ns1__getCourses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCoursesResponse"))
		{	*type = SOAP_TYPE_ns1__getCoursesResponse;
			return soap_in_ns1__getCoursesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourseStudents"))
		{	*type = SOAP_TYPE_ns1__addCourseStudents;
			return soap_in_ns1__addCourseStudents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourseStudentsResponse"))
		{	*type = SOAP_TYPE_ns1__addCourseStudentsResponse;
			return soap_in_ns1__addCourseStudentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourseTeacher"))
		{	*type = SOAP_TYPE_ns1__addCourseTeacher;
			return soap_in_ns1__addCourseTeacher(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourseTeacherResponse"))
		{	*type = SOAP_TYPE_ns1__addCourseTeacherResponse;
			return soap_in_ns1__addCourseTeacherResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourse"))
		{	*type = SOAP_TYPE_ns1__addCourse;
			return soap_in_ns1__addCourse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCourseResponse"))
		{	*type = SOAP_TYPE_ns1__addCourseResponse;
			return soap_in_ns1__addCourseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllGroupsAndClasses"))
		{	*type = SOAP_TYPE_ns1__getAllGroupsAndClasses;
			return soap_in_ns1__getAllGroupsAndClasses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllGroupsAndClassesResponse"))
		{	*type = SOAP_TYPE_ns1__getAllGroupsAndClassesResponse;
			return soap_in_ns1__getAllGroupsAndClassesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllAccountsExtended"))
		{	*type = SOAP_TYPE_ns1__getAllAccountsExtended;
			return soap_in_ns1__getAllAccountsExtended(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllAccountsExtendedResponse"))
		{	*type = SOAP_TYPE_ns1__getAllAccountsExtendedResponse;
			return soap_in_ns1__getAllAccountsExtendedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllAccounts"))
		{	*type = SOAP_TYPE_ns1__getAllAccounts;
			return soap_in_ns1__getAllAccounts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllAccountsResponse"))
		{	*type = SOAP_TYPE_ns1__getAllAccountsResponse;
			return soap_in_ns1__getAllAccountsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveGroup"))
		{	*type = SOAP_TYPE_ns1__saveGroup;
			return soap_in_ns1__saveGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveGroupResponse"))
		{	*type = SOAP_TYPE_ns1__saveGroupResponse;
			return soap_in_ns1__saveGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClass"))
		{	*type = SOAP_TYPE_ns1__saveClass;
			return soap_in_ns1__saveClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveClassResponse"))
		{	*type = SOAP_TYPE_ns1__saveClassResponse;
			return soap_in_ns1__saveClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUser"))
		{	*type = SOAP_TYPE_ns1__saveUser;
			return soap_in_ns1__saveUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserResponse;
			return soap_in_ns1__saveUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__returnJsonErrorCodes:
		return soap_out_ns1__returnJsonErrorCodes(soap, tag, id, (const struct ns1__returnJsonErrorCodes *)ptr, "ns1:returnJsonErrorCodes");
	case SOAP_TYPE_ns1__returnJsonErrorCodesResponse:
		return soap_out_ns1__returnJsonErrorCodesResponse(soap, tag, id, (const struct ns1__returnJsonErrorCodesResponse *)ptr, "ns1:returnJsonErrorCodesResponse");
	case SOAP_TYPE_ns1__returnCsvErrorCodes:
		return soap_out_ns1__returnCsvErrorCodes(soap, tag, id, (const struct ns1__returnCsvErrorCodes *)ptr, "ns1:returnCsvErrorCodes");
	case SOAP_TYPE_ns1__returnCsvErrorCodesResponse:
		return soap_out_ns1__returnCsvErrorCodesResponse(soap, tag, id, (const struct ns1__returnCsvErrorCodesResponse *)ptr, "ns1:returnCsvErrorCodesResponse");
	case SOAP_TYPE_ns1__returnErrorCodes:
		return soap_out_ns1__returnErrorCodes(soap, tag, id, (const struct ns1__returnErrorCodes *)ptr, "ns1:returnErrorCodes");
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthentication:
		return soap_out_ns1__deactivateTwoFactorAuthentication(soap, tag, id, (const struct ns1__deactivateTwoFactorAuthentication *)ptr, "ns1:deactivateTwoFactorAuthentication");
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse:
		return soap_out_ns1__deactivateTwoFactorAuthenticationResponse(soap, tag, id, (const struct ns1__deactivateTwoFactorAuthenticationResponse *)ptr, "ns1:deactivateTwoFactorAuthenticationResponse");
	case SOAP_TYPE_ns1__getStudentCareer:
		return soap_out_ns1__getStudentCareer(soap, tag, id, (const struct ns1__getStudentCareer *)ptr, "ns1:getStudentCareer");
	case SOAP_TYPE_ns1__getStudentCareerResponse:
		return soap_out_ns1__getStudentCareerResponse(soap, tag, id, (const struct ns1__getStudentCareerResponse *)ptr, "ns1:getStudentCareerResponse");
	case SOAP_TYPE_ns1__saveSignature:
		return soap_out_ns1__saveSignature(soap, tag, id, (const struct ns1__saveSignature *)ptr, "ns1:saveSignature");
	case SOAP_TYPE_ns1__saveSignatureResponse:
		return soap_out_ns1__saveSignatureResponse(soap, tag, id, (const struct ns1__saveSignatureResponse *)ptr, "ns1:saveSignatureResponse");
	case SOAP_TYPE_ns1__getUserOfficialClass:
		return soap_out_ns1__getUserOfficialClass(soap, tag, id, (const struct ns1__getUserOfficialClass *)ptr, "ns1:getUserOfficialClass");
	case SOAP_TYPE_ns1__getUserOfficialClassResponse:
		return soap_out_ns1__getUserOfficialClassResponse(soap, tag, id, (const struct ns1__getUserOfficialClassResponse *)ptr, "ns1:getUserOfficialClassResponse");
	case SOAP_TYPE_ns1__getUserDetailsByUsername:
		return soap_out_ns1__getUserDetailsByUsername(soap, tag, id, (const struct ns1__getUserDetailsByUsername *)ptr, "ns1:getUserDetailsByUsername");
	case SOAP_TYPE_ns1__getUserDetailsByUsernameResponse:
		return soap_out_ns1__getUserDetailsByUsernameResponse(soap, tag, id, (const struct ns1__getUserDetailsByUsernameResponse *)ptr, "ns1:getUserDetailsByUsernameResponse");
	case SOAP_TYPE_ns1__getUserDetailsByNumber:
		return soap_out_ns1__getUserDetailsByNumber(soap, tag, id, (const struct ns1__getUserDetailsByNumber *)ptr, "ns1:getUserDetailsByNumber");
	case SOAP_TYPE_ns1__getUserDetailsByNumberResponse:
		return soap_out_ns1__getUserDetailsByNumberResponse(soap, tag, id, (const struct ns1__getUserDetailsByNumberResponse *)ptr, "ns1:getUserDetailsByNumberResponse");
	case SOAP_TYPE_ns1__getUserDetails:
		return soap_out_ns1__getUserDetails(soap, tag, id, (const struct ns1__getUserDetails *)ptr, "ns1:getUserDetails");
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return soap_out_ns1__getUserDetailsResponse(soap, tag, id, (const struct ns1__getUserDetailsResponse *)ptr, "ns1:getUserDetailsResponse");
	case SOAP_TYPE_ns1__getAbsents:
		return soap_out_ns1__getAbsents(soap, tag, id, (const struct ns1__getAbsents *)ptr, "ns1:getAbsents");
	case SOAP_TYPE_ns1__getAbsentsResponse:
		return soap_out_ns1__getAbsentsResponse(soap, tag, id, (const struct ns1__getAbsentsResponse *)ptr, "ns1:getAbsentsResponse");
	case SOAP_TYPE_ns1__getAbsentsByDate:
		return soap_out_ns1__getAbsentsByDate(soap, tag, id, (const struct ns1__getAbsentsByDate *)ptr, "ns1:getAbsentsByDate");
	case SOAP_TYPE_ns1__getAbsentsByDateResponse:
		return soap_out_ns1__getAbsentsByDateResponse(soap, tag, id, (const struct ns1__getAbsentsByDateResponse *)ptr, "ns1:getAbsentsByDateResponse");
	case SOAP_TYPE_ns1__getClassTeachers:
		return soap_out_ns1__getClassTeachers(soap, tag, id, (const struct ns1__getClassTeachers *)ptr, "ns1:getClassTeachers");
	case SOAP_TYPE_ns1__getClassTeachersResponse:
		return soap_out_ns1__getClassTeachersResponse(soap, tag, id, (const struct ns1__getClassTeachersResponse *)ptr, "ns1:getClassTeachersResponse");
	case SOAP_TYPE_ns1__unregisterStudent:
		return soap_out_ns1__unregisterStudent(soap, tag, id, (const struct ns1__unregisterStudent *)ptr, "ns1:unregisterStudent");
	case SOAP_TYPE_ns1__unregisterStudentResponse:
		return soap_out_ns1__unregisterStudentResponse(soap, tag, id, (const struct ns1__unregisterStudentResponse *)ptr, "ns1:unregisterStudentResponse");
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation:
		return soap_out_ns1__getSkoreClassTeacherCourseRelation(soap, tag, id, (const struct ns1__getSkoreClassTeacherCourseRelation *)ptr, "ns1:getSkoreClassTeacherCourseRelation");
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse:
		return soap_out_ns1__getSkoreClassTeacherCourseRelationResponse(soap, tag, id, (const struct ns1__getSkoreClassTeacherCourseRelationResponse *)ptr, "ns1:getSkoreClassTeacherCourseRelationResponse");
	case SOAP_TYPE_ns1__sendMsg:
		return soap_out_ns1__sendMsg(soap, tag, id, (const struct ns1__sendMsg *)ptr, "ns1:sendMsg");
	case SOAP_TYPE_ns1__sendMsgResponse:
		return soap_out_ns1__sendMsgResponse(soap, tag, id, (const struct ns1__sendMsgResponse *)ptr, "ns1:sendMsgResponse");
	case SOAP_TYPE_ns1__savePassword:
		return soap_out_ns1__savePassword(soap, tag, id, (const struct ns1__savePassword *)ptr, "ns1:savePassword");
	case SOAP_TYPE_ns1__savePasswordResponse:
		return soap_out_ns1__savePasswordResponse(soap, tag, id, (const struct ns1__savePasswordResponse *)ptr, "ns1:savePasswordResponse");
	case SOAP_TYPE_ns1__forcePasswordReset:
		return soap_out_ns1__forcePasswordReset(soap, tag, id, (const struct ns1__forcePasswordReset *)ptr, "ns1:forcePasswordReset");
	case SOAP_TYPE_ns1__forcePasswordResetResponse:
		return soap_out_ns1__forcePasswordResetResponse(soap, tag, id, (const struct ns1__forcePasswordResetResponse *)ptr, "ns1:forcePasswordResetResponse");
	case SOAP_TYPE_ns1__replaceInum:
		return soap_out_ns1__replaceInum(soap, tag, id, (const struct ns1__replaceInum *)ptr, "ns1:replaceInum");
	case SOAP_TYPE_ns1__replaceInumResponse:
		return soap_out_ns1__replaceInumResponse(soap, tag, id, (const struct ns1__replaceInumResponse *)ptr, "ns1:replaceInumResponse");
	case SOAP_TYPE_ns1__getAccountPhoto:
		return soap_out_ns1__getAccountPhoto(soap, tag, id, (const struct ns1__getAccountPhoto *)ptr, "ns1:getAccountPhoto");
	case SOAP_TYPE_ns1__getAccountPhotoResponse:
		return soap_out_ns1__getAccountPhotoResponse(soap, tag, id, (const struct ns1__getAccountPhotoResponse *)ptr, "ns1:getAccountPhotoResponse");
	case SOAP_TYPE_ns1__setAccountPhoto:
		return soap_out_ns1__setAccountPhoto(soap, tag, id, (const struct ns1__setAccountPhoto *)ptr, "ns1:setAccountPhoto");
	case SOAP_TYPE_ns1__setAccountPhotoResponse:
		return soap_out_ns1__setAccountPhotoResponse(soap, tag, id, (const struct ns1__setAccountPhotoResponse *)ptr, "ns1:setAccountPhotoResponse");
	case SOAP_TYPE_ns1__setAccountStatus:
		return soap_out_ns1__setAccountStatus(soap, tag, id, (const struct ns1__setAccountStatus *)ptr, "ns1:setAccountStatus");
	case SOAP_TYPE_ns1__setAccountStatusResponse:
		return soap_out_ns1__setAccountStatusResponse(soap, tag, id, (const struct ns1__setAccountStatusResponse *)ptr, "ns1:setAccountStatusResponse");
	case SOAP_TYPE_ns1__saveUserToClassesAndGroups:
		return soap_out_ns1__saveUserToClassesAndGroups(soap, tag, id, (const struct ns1__saveUserToClassesAndGroups *)ptr, "ns1:saveUserToClassesAndGroups");
	case SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse:
		return soap_out_ns1__saveUserToClassesAndGroupsResponse(soap, tag, id, (const struct ns1__saveUserToClassesAndGroupsResponse *)ptr, "ns1:saveUserToClassesAndGroupsResponse");
	case SOAP_TYPE_ns1__saveUserToClass:
		return soap_out_ns1__saveUserToClass(soap, tag, id, (const struct ns1__saveUserToClass *)ptr, "ns1:saveUserToClass");
	case SOAP_TYPE_ns1__saveUserToClassResponse:
		return soap_out_ns1__saveUserToClassResponse(soap, tag, id, (const struct ns1__saveUserToClassResponse *)ptr, "ns1:saveUserToClassResponse");
	case SOAP_TYPE_ns1__removeUserFromGroup:
		return soap_out_ns1__removeUserFromGroup(soap, tag, id, (const struct ns1__removeUserFromGroup *)ptr, "ns1:removeUserFromGroup");
	case SOAP_TYPE_ns1__removeUserFromGroupResponse:
		return soap_out_ns1__removeUserFromGroupResponse(soap, tag, id, (const struct ns1__removeUserFromGroupResponse *)ptr, "ns1:removeUserFromGroupResponse");
	case SOAP_TYPE_ns1__saveUserToClasses:
		return soap_out_ns1__saveUserToClasses(soap, tag, id, (const struct ns1__saveUserToClasses *)ptr, "ns1:saveUserToClasses");
	case SOAP_TYPE_ns1__saveUserToClassesResponse:
		return soap_out_ns1__saveUserToClassesResponse(soap, tag, id, (const struct ns1__saveUserToClassesResponse *)ptr, "ns1:saveUserToClassesResponse");
	case SOAP_TYPE_ns1__delClass:
		return soap_out_ns1__delClass(soap, tag, id, (const struct ns1__delClass *)ptr, "ns1:delClass");
	case SOAP_TYPE_ns1__delClassResponse:
		return soap_out_ns1__delClassResponse(soap, tag, id, (const struct ns1__delClassResponse *)ptr, "ns1:delClassResponse");
	case SOAP_TYPE_ns1__saveClassListJson:
		return soap_out_ns1__saveClassListJson(soap, tag, id, (const struct ns1__saveClassListJson *)ptr, "ns1:saveClassListJson");
	case SOAP_TYPE_ns1__saveClassListJsonResponse:
		return soap_out_ns1__saveClassListJsonResponse(soap, tag, id, (const struct ns1__saveClassListJsonResponse *)ptr, "ns1:saveClassListJsonResponse");
	case SOAP_TYPE_ns1__saveClassList:
		return soap_out_ns1__saveClassList(soap, tag, id, (const struct ns1__saveClassList *)ptr, "ns1:saveClassList");
	case SOAP_TYPE_ns1__saveClassListResponse:
		return soap_out_ns1__saveClassListResponse(soap, tag, id, (const struct ns1__saveClassListResponse *)ptr, "ns1:saveClassListResponse");
	case SOAP_TYPE_ns1__getClassListJson:
		return soap_out_ns1__getClassListJson(soap, tag, id, (const struct ns1__getClassListJson *)ptr, "ns1:getClassListJson");
	case SOAP_TYPE_ns1__getClassListJsonResponse:
		return soap_out_ns1__getClassListJsonResponse(soap, tag, id, (const struct ns1__getClassListJsonResponse *)ptr, "ns1:getClassListJsonResponse");
	case SOAP_TYPE_ns1__getClassList:
		return soap_out_ns1__getClassList(soap, tag, id, (const struct ns1__getClassList *)ptr, "ns1:getClassList");
	case SOAP_TYPE_ns1__getClassListResponse:
		return soap_out_ns1__getClassListResponse(soap, tag, id, (const struct ns1__getClassListResponse *)ptr, "ns1:getClassListResponse");
	case SOAP_TYPE_ns1__saveUserParameter:
		return soap_out_ns1__saveUserParameter(soap, tag, id, (const struct ns1__saveUserParameter *)ptr, "ns1:saveUserParameter");
	case SOAP_TYPE_ns1__saveUserParameterResponse:
		return soap_out_ns1__saveUserParameterResponse(soap, tag, id, (const struct ns1__saveUserParameterResponse *)ptr, "ns1:saveUserParameterResponse");
	case SOAP_TYPE_ns1__delUser:
		return soap_out_ns1__delUser(soap, tag, id, (const struct ns1__delUser *)ptr, "ns1:delUser");
	case SOAP_TYPE_ns1__delUserResponse:
		return soap_out_ns1__delUserResponse(soap, tag, id, (const struct ns1__delUserResponse *)ptr, "ns1:delUserResponse");
	case SOAP_TYPE_ns1__getCourses:
		return soap_out_ns1__getCourses(soap, tag, id, (const struct ns1__getCourses *)ptr, "ns1:getCourses");
	case SOAP_TYPE_ns1__getCoursesResponse:
		return soap_out_ns1__getCoursesResponse(soap, tag, id, (const struct ns1__getCoursesResponse *)ptr, "ns1:getCoursesResponse");
	case SOAP_TYPE_ns1__addCourseStudents:
		return soap_out_ns1__addCourseStudents(soap, tag, id, (const struct ns1__addCourseStudents *)ptr, "ns1:addCourseStudents");
	case SOAP_TYPE_ns1__addCourseStudentsResponse:
		return soap_out_ns1__addCourseStudentsResponse(soap, tag, id, (const struct ns1__addCourseStudentsResponse *)ptr, "ns1:addCourseStudentsResponse");
	case SOAP_TYPE_ns1__addCourseTeacher:
		return soap_out_ns1__addCourseTeacher(soap, tag, id, (const struct ns1__addCourseTeacher *)ptr, "ns1:addCourseTeacher");
	case SOAP_TYPE_ns1__addCourseTeacherResponse:
		return soap_out_ns1__addCourseTeacherResponse(soap, tag, id, (const struct ns1__addCourseTeacherResponse *)ptr, "ns1:addCourseTeacherResponse");
	case SOAP_TYPE_ns1__addCourse:
		return soap_out_ns1__addCourse(soap, tag, id, (const struct ns1__addCourse *)ptr, "ns1:addCourse");
	case SOAP_TYPE_ns1__addCourseResponse:
		return soap_out_ns1__addCourseResponse(soap, tag, id, (const struct ns1__addCourseResponse *)ptr, "ns1:addCourseResponse");
	case SOAP_TYPE_ns1__getAllGroupsAndClasses:
		return soap_out_ns1__getAllGroupsAndClasses(soap, tag, id, (const struct ns1__getAllGroupsAndClasses *)ptr, "ns1:getAllGroupsAndClasses");
	case SOAP_TYPE_ns1__getAllGroupsAndClassesResponse:
		return soap_out_ns1__getAllGroupsAndClassesResponse(soap, tag, id, (const struct ns1__getAllGroupsAndClassesResponse *)ptr, "ns1:getAllGroupsAndClassesResponse");
	case SOAP_TYPE_ns1__getAllAccountsExtended:
		return soap_out_ns1__getAllAccountsExtended(soap, tag, id, (const struct ns1__getAllAccountsExtended *)ptr, "ns1:getAllAccountsExtended");
	case SOAP_TYPE_ns1__getAllAccountsExtendedResponse:
		return soap_out_ns1__getAllAccountsExtendedResponse(soap, tag, id, (const struct ns1__getAllAccountsExtendedResponse *)ptr, "ns1:getAllAccountsExtendedResponse");
	case SOAP_TYPE_ns1__getAllAccounts:
		return soap_out_ns1__getAllAccounts(soap, tag, id, (const struct ns1__getAllAccounts *)ptr, "ns1:getAllAccounts");
	case SOAP_TYPE_ns1__getAllAccountsResponse:
		return soap_out_ns1__getAllAccountsResponse(soap, tag, id, (const struct ns1__getAllAccountsResponse *)ptr, "ns1:getAllAccountsResponse");
	case SOAP_TYPE_ns1__saveGroup:
		return soap_out_ns1__saveGroup(soap, tag, id, (const struct ns1__saveGroup *)ptr, "ns1:saveGroup");
	case SOAP_TYPE_ns1__saveGroupResponse:
		return soap_out_ns1__saveGroupResponse(soap, tag, id, (const struct ns1__saveGroupResponse *)ptr, "ns1:saveGroupResponse");
	case SOAP_TYPE_ns1__saveClass:
		return soap_out_ns1__saveClass(soap, tag, id, (const struct ns1__saveClass *)ptr, "ns1:saveClass");
	case SOAP_TYPE_ns1__saveClassResponse:
		return soap_out_ns1__saveClassResponse(soap, tag, id, (const struct ns1__saveClassResponse *)ptr, "ns1:saveClassResponse");
	case SOAP_TYPE_ns1__saveUser:
		return soap_out_ns1__saveUser(soap, tag, id, (const struct ns1__saveUser *)ptr, "ns1:saveUser");
	case SOAP_TYPE_ns1__saveUserResponse:
		return soap_out_ns1__saveUserResponse(soap, tag, id, (const struct ns1__saveUserResponse *)ptr, "ns1:saveUserResponse");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__returnJsonErrorCodes:
		soap_serialize_ns1__returnJsonErrorCodes(soap, (const struct ns1__returnJsonErrorCodes *)ptr);
		break;
	case SOAP_TYPE_ns1__returnJsonErrorCodesResponse:
		soap_serialize_ns1__returnJsonErrorCodesResponse(soap, (const struct ns1__returnJsonErrorCodesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__returnCsvErrorCodes:
		soap_serialize_ns1__returnCsvErrorCodes(soap, (const struct ns1__returnCsvErrorCodes *)ptr);
		break;
	case SOAP_TYPE_ns1__returnCsvErrorCodesResponse:
		soap_serialize_ns1__returnCsvErrorCodesResponse(soap, (const struct ns1__returnCsvErrorCodesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__returnErrorCodes:
		soap_serialize_ns1__returnErrorCodes(soap, (const struct ns1__returnErrorCodes *)ptr);
		break;
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthentication:
		soap_serialize_ns1__deactivateTwoFactorAuthentication(soap, (const struct ns1__deactivateTwoFactorAuthentication *)ptr);
		break;
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse:
		soap_serialize_ns1__deactivateTwoFactorAuthenticationResponse(soap, (const struct ns1__deactivateTwoFactorAuthenticationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getStudentCareer:
		soap_serialize_ns1__getStudentCareer(soap, (const struct ns1__getStudentCareer *)ptr);
		break;
	case SOAP_TYPE_ns1__getStudentCareerResponse:
		soap_serialize_ns1__getStudentCareerResponse(soap, (const struct ns1__getStudentCareerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveSignature:
		soap_serialize_ns1__saveSignature(soap, (const struct ns1__saveSignature *)ptr);
		break;
	case SOAP_TYPE_ns1__saveSignatureResponse:
		soap_serialize_ns1__saveSignatureResponse(soap, (const struct ns1__saveSignatureResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserOfficialClass:
		soap_serialize_ns1__getUserOfficialClass(soap, (const struct ns1__getUserOfficialClass *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserOfficialClassResponse:
		soap_serialize_ns1__getUserOfficialClassResponse(soap, (const struct ns1__getUserOfficialClassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByUsername:
		soap_serialize_ns1__getUserDetailsByUsername(soap, (const struct ns1__getUserDetailsByUsername *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByUsernameResponse:
		soap_serialize_ns1__getUserDetailsByUsernameResponse(soap, (const struct ns1__getUserDetailsByUsernameResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByNumber:
		soap_serialize_ns1__getUserDetailsByNumber(soap, (const struct ns1__getUserDetailsByNumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByNumberResponse:
		soap_serialize_ns1__getUserDetailsByNumberResponse(soap, (const struct ns1__getUserDetailsByNumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetails:
		soap_serialize_ns1__getUserDetails(soap, (const struct ns1__getUserDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		soap_serialize_ns1__getUserDetailsResponse(soap, (const struct ns1__getUserDetailsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAbsents:
		soap_serialize_ns1__getAbsents(soap, (const struct ns1__getAbsents *)ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsResponse:
		soap_serialize_ns1__getAbsentsResponse(soap, (const struct ns1__getAbsentsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsByDate:
		soap_serialize_ns1__getAbsentsByDate(soap, (const struct ns1__getAbsentsByDate *)ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsByDateResponse:
		soap_serialize_ns1__getAbsentsByDateResponse(soap, (const struct ns1__getAbsentsByDateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassTeachers:
		soap_serialize_ns1__getClassTeachers(soap, (const struct ns1__getClassTeachers *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassTeachersResponse:
		soap_serialize_ns1__getClassTeachersResponse(soap, (const struct ns1__getClassTeachersResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__unregisterStudent:
		soap_serialize_ns1__unregisterStudent(soap, (const struct ns1__unregisterStudent *)ptr);
		break;
	case SOAP_TYPE_ns1__unregisterStudentResponse:
		soap_serialize_ns1__unregisterStudentResponse(soap, (const struct ns1__unregisterStudentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation:
		soap_serialize_ns1__getSkoreClassTeacherCourseRelation(soap, (const struct ns1__getSkoreClassTeacherCourseRelation *)ptr);
		break;
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse:
		soap_serialize_ns1__getSkoreClassTeacherCourseRelationResponse(soap, (const struct ns1__getSkoreClassTeacherCourseRelationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__sendMsg:
		soap_serialize_ns1__sendMsg(soap, (const struct ns1__sendMsg *)ptr);
		break;
	case SOAP_TYPE_ns1__sendMsgResponse:
		soap_serialize_ns1__sendMsgResponse(soap, (const struct ns1__sendMsgResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__savePassword:
		soap_serialize_ns1__savePassword(soap, (const struct ns1__savePassword *)ptr);
		break;
	case SOAP_TYPE_ns1__savePasswordResponse:
		soap_serialize_ns1__savePasswordResponse(soap, (const struct ns1__savePasswordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__forcePasswordReset:
		soap_serialize_ns1__forcePasswordReset(soap, (const struct ns1__forcePasswordReset *)ptr);
		break;
	case SOAP_TYPE_ns1__forcePasswordResetResponse:
		soap_serialize_ns1__forcePasswordResetResponse(soap, (const struct ns1__forcePasswordResetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__replaceInum:
		soap_serialize_ns1__replaceInum(soap, (const struct ns1__replaceInum *)ptr);
		break;
	case SOAP_TYPE_ns1__replaceInumResponse:
		soap_serialize_ns1__replaceInumResponse(soap, (const struct ns1__replaceInumResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAccountPhoto:
		soap_serialize_ns1__getAccountPhoto(soap, (const struct ns1__getAccountPhoto *)ptr);
		break;
	case SOAP_TYPE_ns1__getAccountPhotoResponse:
		soap_serialize_ns1__getAccountPhotoResponse(soap, (const struct ns1__getAccountPhotoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__setAccountPhoto:
		soap_serialize_ns1__setAccountPhoto(soap, (const struct ns1__setAccountPhoto *)ptr);
		break;
	case SOAP_TYPE_ns1__setAccountPhotoResponse:
		soap_serialize_ns1__setAccountPhotoResponse(soap, (const struct ns1__setAccountPhotoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__setAccountStatus:
		soap_serialize_ns1__setAccountStatus(soap, (const struct ns1__setAccountStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__setAccountStatusResponse:
		soap_serialize_ns1__setAccountStatusResponse(soap, (const struct ns1__setAccountStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesAndGroups:
		soap_serialize_ns1__saveUserToClassesAndGroups(soap, (const struct ns1__saveUserToClassesAndGroups *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse:
		soap_serialize_ns1__saveUserToClassesAndGroupsResponse(soap, (const struct ns1__saveUserToClassesAndGroupsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClass:
		soap_serialize_ns1__saveUserToClass(soap, (const struct ns1__saveUserToClass *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassResponse:
		soap_serialize_ns1__saveUserToClassResponse(soap, (const struct ns1__saveUserToClassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__removeUserFromGroup:
		soap_serialize_ns1__removeUserFromGroup(soap, (const struct ns1__removeUserFromGroup *)ptr);
		break;
	case SOAP_TYPE_ns1__removeUserFromGroupResponse:
		soap_serialize_ns1__removeUserFromGroupResponse(soap, (const struct ns1__removeUserFromGroupResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClasses:
		soap_serialize_ns1__saveUserToClasses(soap, (const struct ns1__saveUserToClasses *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesResponse:
		soap_serialize_ns1__saveUserToClassesResponse(soap, (const struct ns1__saveUserToClassesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__delClass:
		soap_serialize_ns1__delClass(soap, (const struct ns1__delClass *)ptr);
		break;
	case SOAP_TYPE_ns1__delClassResponse:
		soap_serialize_ns1__delClassResponse(soap, (const struct ns1__delClassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListJson:
		soap_serialize_ns1__saveClassListJson(soap, (const struct ns1__saveClassListJson *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListJsonResponse:
		soap_serialize_ns1__saveClassListJsonResponse(soap, (const struct ns1__saveClassListJsonResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClassList:
		soap_serialize_ns1__saveClassList(soap, (const struct ns1__saveClassList *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListResponse:
		soap_serialize_ns1__saveClassListResponse(soap, (const struct ns1__saveClassListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassListJson:
		soap_serialize_ns1__getClassListJson(soap, (const struct ns1__getClassListJson *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassListJsonResponse:
		soap_serialize_ns1__getClassListJsonResponse(soap, (const struct ns1__getClassListJsonResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassList:
		soap_serialize_ns1__getClassList(soap, (const struct ns1__getClassList *)ptr);
		break;
	case SOAP_TYPE_ns1__getClassListResponse:
		soap_serialize_ns1__getClassListResponse(soap, (const struct ns1__getClassListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserParameter:
		soap_serialize_ns1__saveUserParameter(soap, (const struct ns1__saveUserParameter *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserParameterResponse:
		soap_serialize_ns1__saveUserParameterResponse(soap, (const struct ns1__saveUserParameterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__delUser:
		soap_serialize_ns1__delUser(soap, (const struct ns1__delUser *)ptr);
		break;
	case SOAP_TYPE_ns1__delUserResponse:
		soap_serialize_ns1__delUserResponse(soap, (const struct ns1__delUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCourses:
		soap_serialize_ns1__getCourses(soap, (const struct ns1__getCourses *)ptr);
		break;
	case SOAP_TYPE_ns1__getCoursesResponse:
		soap_serialize_ns1__getCoursesResponse(soap, (const struct ns1__getCoursesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourseStudents:
		soap_serialize_ns1__addCourseStudents(soap, (const struct ns1__addCourseStudents *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourseStudentsResponse:
		soap_serialize_ns1__addCourseStudentsResponse(soap, (const struct ns1__addCourseStudentsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourseTeacher:
		soap_serialize_ns1__addCourseTeacher(soap, (const struct ns1__addCourseTeacher *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourseTeacherResponse:
		soap_serialize_ns1__addCourseTeacherResponse(soap, (const struct ns1__addCourseTeacherResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourse:
		soap_serialize_ns1__addCourse(soap, (const struct ns1__addCourse *)ptr);
		break;
	case SOAP_TYPE_ns1__addCourseResponse:
		soap_serialize_ns1__addCourseResponse(soap, (const struct ns1__addCourseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllGroupsAndClasses:
		soap_serialize_ns1__getAllGroupsAndClasses(soap, (const struct ns1__getAllGroupsAndClasses *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllGroupsAndClassesResponse:
		soap_serialize_ns1__getAllGroupsAndClassesResponse(soap, (const struct ns1__getAllGroupsAndClassesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsExtended:
		soap_serialize_ns1__getAllAccountsExtended(soap, (const struct ns1__getAllAccountsExtended *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsExtendedResponse:
		soap_serialize_ns1__getAllAccountsExtendedResponse(soap, (const struct ns1__getAllAccountsExtendedResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccounts:
		soap_serialize_ns1__getAllAccounts(soap, (const struct ns1__getAllAccounts *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsResponse:
		soap_serialize_ns1__getAllAccountsResponse(soap, (const struct ns1__getAllAccountsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveGroup:
		soap_serialize_ns1__saveGroup(soap, (const struct ns1__saveGroup *)ptr);
		break;
	case SOAP_TYPE_ns1__saveGroupResponse:
		soap_serialize_ns1__saveGroupResponse(soap, (const struct ns1__saveGroupResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClass:
		soap_serialize_ns1__saveClass(soap, (const struct ns1__saveClass *)ptr);
		break;
	case SOAP_TYPE_ns1__saveClassResponse:
		soap_serialize_ns1__saveClassResponse(soap, (const struct ns1__saveClassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUser:
		soap_serialize_ns1__saveUser(soap, (const struct ns1__saveUser *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserResponse:
		soap_serialize_ns1__saveUserResponse(soap, (const struct ns1__saveUserResponse *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserResponse:
		return (void*)soap_instantiate_ns1__saveUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUser:
		return (void*)soap_instantiate_ns1__saveUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClassResponse:
		return (void*)soap_instantiate_ns1__saveClassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClass:
		return (void*)soap_instantiate_ns1__saveClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveGroupResponse:
		return (void*)soap_instantiate_ns1__saveGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveGroup:
		return (void*)soap_instantiate_ns1__saveGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllAccountsResponse:
		return (void*)soap_instantiate_ns1__getAllAccountsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllAccounts:
		return (void*)soap_instantiate_ns1__getAllAccounts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllAccountsExtendedResponse:
		return (void*)soap_instantiate_ns1__getAllAccountsExtendedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllAccountsExtended:
		return (void*)soap_instantiate_ns1__getAllAccountsExtended(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllGroupsAndClassesResponse:
		return (void*)soap_instantiate_ns1__getAllGroupsAndClassesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllGroupsAndClasses:
		return (void*)soap_instantiate_ns1__getAllGroupsAndClasses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourseResponse:
		return (void*)soap_instantiate_ns1__addCourseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourse:
		return (void*)soap_instantiate_ns1__addCourse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourseTeacherResponse:
		return (void*)soap_instantiate_ns1__addCourseTeacherResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourseTeacher:
		return (void*)soap_instantiate_ns1__addCourseTeacher(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourseStudentsResponse:
		return (void*)soap_instantiate_ns1__addCourseStudentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCourseStudents:
		return (void*)soap_instantiate_ns1__addCourseStudents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCoursesResponse:
		return (void*)soap_instantiate_ns1__getCoursesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCourses:
		return (void*)soap_instantiate_ns1__getCourses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delUserResponse:
		return (void*)soap_instantiate_ns1__delUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delUser:
		return (void*)soap_instantiate_ns1__delUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserParameterResponse:
		return (void*)soap_instantiate_ns1__saveUserParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserParameter:
		return (void*)soap_instantiate_ns1__saveUserParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassListResponse:
		return (void*)soap_instantiate_ns1__getClassListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassList:
		return (void*)soap_instantiate_ns1__getClassList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassListJsonResponse:
		return (void*)soap_instantiate_ns1__getClassListJsonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassListJson:
		return (void*)soap_instantiate_ns1__getClassListJson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClassListResponse:
		return (void*)soap_instantiate_ns1__saveClassListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClassList:
		return (void*)soap_instantiate_ns1__saveClassList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClassListJsonResponse:
		return (void*)soap_instantiate_ns1__saveClassListJsonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveClassListJson:
		return (void*)soap_instantiate_ns1__saveClassListJson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delClassResponse:
		return (void*)soap_instantiate_ns1__delClassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delClass:
		return (void*)soap_instantiate_ns1__delClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClassesResponse:
		return (void*)soap_instantiate_ns1__saveUserToClassesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClasses:
		return (void*)soap_instantiate_ns1__saveUserToClasses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeUserFromGroupResponse:
		return (void*)soap_instantiate_ns1__removeUserFromGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeUserFromGroup:
		return (void*)soap_instantiate_ns1__removeUserFromGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClassResponse:
		return (void*)soap_instantiate_ns1__saveUserToClassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClass:
		return (void*)soap_instantiate_ns1__saveUserToClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse:
		return (void*)soap_instantiate_ns1__saveUserToClassesAndGroupsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserToClassesAndGroups:
		return (void*)soap_instantiate_ns1__saveUserToClassesAndGroups(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setAccountStatusResponse:
		return (void*)soap_instantiate_ns1__setAccountStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setAccountStatus:
		return (void*)soap_instantiate_ns1__setAccountStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setAccountPhotoResponse:
		return (void*)soap_instantiate_ns1__setAccountPhotoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setAccountPhoto:
		return (void*)soap_instantiate_ns1__setAccountPhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccountPhotoResponse:
		return (void*)soap_instantiate_ns1__getAccountPhotoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccountPhoto:
		return (void*)soap_instantiate_ns1__getAccountPhoto(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__replaceInumResponse:
		return (void*)soap_instantiate_ns1__replaceInumResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__replaceInum:
		return (void*)soap_instantiate_ns1__replaceInum(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__forcePasswordResetResponse:
		return (void*)soap_instantiate_ns1__forcePasswordResetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__forcePasswordReset:
		return (void*)soap_instantiate_ns1__forcePasswordReset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__savePasswordResponse:
		return (void*)soap_instantiate_ns1__savePasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__savePassword:
		return (void*)soap_instantiate_ns1__savePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendMsgResponse:
		return (void*)soap_instantiate_ns1__sendMsgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendMsg:
		return (void*)soap_instantiate_ns1__sendMsg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse:
		return (void*)soap_instantiate_ns1__getSkoreClassTeacherCourseRelationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation:
		return (void*)soap_instantiate_ns1__getSkoreClassTeacherCourseRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unregisterStudentResponse:
		return (void*)soap_instantiate_ns1__unregisterStudentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unregisterStudent:
		return (void*)soap_instantiate_ns1__unregisterStudent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassTeachersResponse:
		return (void*)soap_instantiate_ns1__getClassTeachersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getClassTeachers:
		return (void*)soap_instantiate_ns1__getClassTeachers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAbsentsByDateResponse:
		return (void*)soap_instantiate_ns1__getAbsentsByDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAbsentsByDate:
		return (void*)soap_instantiate_ns1__getAbsentsByDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAbsentsResponse:
		return (void*)soap_instantiate_ns1__getAbsentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAbsents:
		return (void*)soap_instantiate_ns1__getAbsents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		return (void*)soap_instantiate_ns1__getUserDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetails:
		return (void*)soap_instantiate_ns1__getUserDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsByNumberResponse:
		return (void*)soap_instantiate_ns1__getUserDetailsByNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsByNumber:
		return (void*)soap_instantiate_ns1__getUserDetailsByNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsByUsernameResponse:
		return (void*)soap_instantiate_ns1__getUserDetailsByUsernameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDetailsByUsername:
		return (void*)soap_instantiate_ns1__getUserDetailsByUsername(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserOfficialClassResponse:
		return (void*)soap_instantiate_ns1__getUserOfficialClassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserOfficialClass:
		return (void*)soap_instantiate_ns1__getUserOfficialClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveSignatureResponse:
		return (void*)soap_instantiate_ns1__saveSignatureResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveSignature:
		return (void*)soap_instantiate_ns1__saveSignature(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStudentCareerResponse:
		return (void*)soap_instantiate_ns1__getStudentCareerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStudentCareer:
		return (void*)soap_instantiate_ns1__getStudentCareer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse:
		return (void*)soap_instantiate_ns1__deactivateTwoFactorAuthenticationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthentication:
		return (void*)soap_instantiate_ns1__deactivateTwoFactorAuthentication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnErrorCodes:
		return (void*)soap_instantiate_ns1__returnErrorCodes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnCsvErrorCodesResponse:
		return (void*)soap_instantiate_ns1__returnCsvErrorCodesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnCsvErrorCodes:
		return (void*)soap_instantiate_ns1__returnCsvErrorCodes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnJsonErrorCodesResponse:
		return (void*)soap_instantiate_ns1__returnJsonErrorCodesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__returnJsonErrorCodes:
		return (void*)soap_instantiate_ns1__returnJsonErrorCodes(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyAttribute:
		return (void*)soap_instantiate_xsd__anyAttribute(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClassResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClassResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClassResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClass:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClass*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClass*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveGroupResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveGroupResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveGroupResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveGroup:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllAccountsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllAccountsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccounts:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllAccounts*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllAccounts*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsExtendedResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllAccountsExtendedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllAccountsExtendedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllAccountsExtended:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllAccountsExtended*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllAccountsExtended*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllGroupsAndClassesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllGroupsAndClassesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllGroupsAndClassesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAllGroupsAndClasses:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAllGroupsAndClasses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAllGroupsAndClasses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourseTeacherResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourseTeacherResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourseTeacherResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourseTeacher:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourseTeacher*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourseTeacher*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourseStudentsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourseStudentsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourseStudentsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCourseStudents:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCourseStudents*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCourseStudents*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCoursesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCoursesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCoursesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCourses:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCourses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCourses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__delUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__delUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__delUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__delUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserParameterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserParameterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserParameterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserParameter:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserParameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserParameter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassListJsonResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassListJsonResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassListJsonResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassListJson:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassListJson*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassListJson*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClassListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClassListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClassList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClassList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClassList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListJsonResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClassListJsonResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClassListJsonResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveClassListJson:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveClassListJson*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveClassListJson*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delClassResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__delClassResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__delClassResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delClass:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__delClass*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__delClass*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClassesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClassesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClasses:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClasses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClasses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeUserFromGroupResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeUserFromGroupResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeUserFromGroupResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeUserFromGroup:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeUserFromGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeUserFromGroup*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClassResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClassResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClass:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClass*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClass*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClassesAndGroupsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClassesAndGroupsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserToClassesAndGroups:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserToClassesAndGroups*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserToClassesAndGroups*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setAccountStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__setAccountStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__setAccountStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setAccountStatus:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__setAccountStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__setAccountStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setAccountPhotoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__setAccountPhotoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__setAccountPhotoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__setAccountPhoto:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__setAccountPhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__setAccountPhoto*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccountPhotoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAccountPhotoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAccountPhotoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccountPhoto:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAccountPhoto*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAccountPhoto*)p->ptr);
		break;
	case SOAP_TYPE_ns1__replaceInumResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__replaceInumResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__replaceInumResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__replaceInum:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__replaceInum*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__replaceInum*)p->ptr);
		break;
	case SOAP_TYPE_ns1__forcePasswordResetResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__forcePasswordResetResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__forcePasswordResetResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__forcePasswordReset:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__forcePasswordReset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__forcePasswordReset*)p->ptr);
		break;
	case SOAP_TYPE_ns1__savePasswordResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__savePasswordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__savePasswordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__savePassword:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__savePassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__savePassword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendMsgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__sendMsgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__sendMsgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendMsg:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__sendMsg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__sendMsg*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSkoreClassTeacherCourseRelationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSkoreClassTeacherCourseRelationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSkoreClassTeacherCourseRelation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSkoreClassTeacherCourseRelation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__unregisterStudentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__unregisterStudentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__unregisterStudentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__unregisterStudent:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__unregisterStudent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__unregisterStudent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassTeachersResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassTeachersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassTeachersResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getClassTeachers:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getClassTeachers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getClassTeachers*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsByDateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAbsentsByDateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAbsentsByDateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsByDate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAbsentsByDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAbsentsByDate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAbsentsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAbsentsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAbsentsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAbsents:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAbsents*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAbsents*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetailsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetailsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetails:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetails*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetails*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByNumberResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetailsByNumberResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetailsByNumberResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByNumber:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetailsByNumber*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetailsByNumber*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByUsernameResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetailsByUsernameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetailsByUsernameResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserDetailsByUsername:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserDetailsByUsername*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserDetailsByUsername*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserOfficialClassResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserOfficialClassResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserOfficialClassResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserOfficialClass:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserOfficialClass*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserOfficialClass*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveSignatureResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveSignatureResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveSignatureResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveSignature:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveSignature*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveSignature*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStudentCareerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getStudentCareerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getStudentCareerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStudentCareer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getStudentCareer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getStudentCareer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deactivateTwoFactorAuthenticationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deactivateTwoFactorAuthenticationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deactivateTwoFactorAuthentication:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deactivateTwoFactorAuthentication*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deactivateTwoFactorAuthentication*)p->ptr);
		break;
	case SOAP_TYPE_ns1__returnErrorCodes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__returnErrorCodes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__returnErrorCodes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__returnCsvErrorCodesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__returnCsvErrorCodesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__returnCsvErrorCodesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__returnCsvErrorCodes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__returnCsvErrorCodes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__returnCsvErrorCodes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__returnJsonErrorCodesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__returnJsonErrorCodesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__returnJsonErrorCodesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__returnJsonErrorCodes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__returnJsonErrorCodes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__returnJsonErrorCodes*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_element*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_element*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_attribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_attribute*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__returnJsonErrorCodes(struct soap *soap, struct ns1__returnJsonErrorCodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__returnJsonErrorCodes(struct soap *soap, const struct ns1__returnJsonErrorCodes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnJsonErrorCodes(struct soap *soap, const char *tag, int id, const struct ns1__returnJsonErrorCodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnJsonErrorCodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__returnJsonErrorCodes * SOAP_FMAC4 soap_in_ns1__returnJsonErrorCodes(struct soap *soap, const char *tag, struct ns1__returnJsonErrorCodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__returnJsonErrorCodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnJsonErrorCodes, sizeof(struct ns1__returnJsonErrorCodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__returnJsonErrorCodes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__returnJsonErrorCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnJsonErrorCodes, 0, sizeof(struct ns1__returnJsonErrorCodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__returnJsonErrorCodes(struct soap *soap, const struct ns1__returnJsonErrorCodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__returnJsonErrorCodes);
	if (soap_out_ns1__returnJsonErrorCodes(soap, tag?tag:"ns1:returnJsonErrorCodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__returnJsonErrorCodes * SOAP_FMAC4 soap_get_ns1__returnJsonErrorCodes(struct soap *soap, struct ns1__returnJsonErrorCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnJsonErrorCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__returnJsonErrorCodes * SOAP_FMAC2 soap_instantiate_ns1__returnJsonErrorCodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnJsonErrorCodes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__returnJsonErrorCodes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__returnJsonErrorCodes);
		if (size)
			*size = sizeof(struct ns1__returnJsonErrorCodes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__returnJsonErrorCodes, n);
		if (size)
			*size = n * sizeof(struct ns1__returnJsonErrorCodes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__returnJsonErrorCodes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__returnJsonErrorCodes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__returnJsonErrorCodes %p -> %p\n", q, p));
	*(struct ns1__returnJsonErrorCodes*)p = *(struct ns1__returnJsonErrorCodes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__returnJsonErrorCodesResponse(struct soap *soap, struct ns1__returnJsonErrorCodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__returnJsonErrorCodesResponse(struct soap *soap, const struct ns1__returnJsonErrorCodesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnJsonErrorCodesResponse(struct soap *soap, const char *tag, int id, const struct ns1__returnJsonErrorCodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnJsonErrorCodesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__returnJsonErrorCodesResponse * SOAP_FMAC4 soap_in_ns1__returnJsonErrorCodesResponse(struct soap *soap, const char *tag, struct ns1__returnJsonErrorCodesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__returnJsonErrorCodesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnJsonErrorCodesResponse, sizeof(struct ns1__returnJsonErrorCodesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__returnJsonErrorCodesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__returnJsonErrorCodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnJsonErrorCodesResponse, 0, sizeof(struct ns1__returnJsonErrorCodesResponse), 0, soap_copy_ns1__returnJsonErrorCodesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__returnJsonErrorCodesResponse(struct soap *soap, const struct ns1__returnJsonErrorCodesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__returnJsonErrorCodesResponse);
	if (soap_out_ns1__returnJsonErrorCodesResponse(soap, tag?tag:"ns1:returnJsonErrorCodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__returnJsonErrorCodesResponse * SOAP_FMAC4 soap_get_ns1__returnJsonErrorCodesResponse(struct soap *soap, struct ns1__returnJsonErrorCodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnJsonErrorCodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__returnJsonErrorCodesResponse * SOAP_FMAC2 soap_instantiate_ns1__returnJsonErrorCodesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnJsonErrorCodesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__returnJsonErrorCodesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__returnJsonErrorCodesResponse);
		if (size)
			*size = sizeof(struct ns1__returnJsonErrorCodesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__returnJsonErrorCodesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__returnJsonErrorCodesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__returnJsonErrorCodesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__returnJsonErrorCodesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__returnJsonErrorCodesResponse %p -> %p\n", q, p));
	*(struct ns1__returnJsonErrorCodesResponse*)p = *(struct ns1__returnJsonErrorCodesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__returnCsvErrorCodes(struct soap *soap, struct ns1__returnCsvErrorCodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__returnCsvErrorCodes(struct soap *soap, const struct ns1__returnCsvErrorCodes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnCsvErrorCodes(struct soap *soap, const char *tag, int id, const struct ns1__returnCsvErrorCodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnCsvErrorCodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__returnCsvErrorCodes * SOAP_FMAC4 soap_in_ns1__returnCsvErrorCodes(struct soap *soap, const char *tag, struct ns1__returnCsvErrorCodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__returnCsvErrorCodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnCsvErrorCodes, sizeof(struct ns1__returnCsvErrorCodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__returnCsvErrorCodes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__returnCsvErrorCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnCsvErrorCodes, 0, sizeof(struct ns1__returnCsvErrorCodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__returnCsvErrorCodes(struct soap *soap, const struct ns1__returnCsvErrorCodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__returnCsvErrorCodes);
	if (soap_out_ns1__returnCsvErrorCodes(soap, tag?tag:"ns1:returnCsvErrorCodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__returnCsvErrorCodes * SOAP_FMAC4 soap_get_ns1__returnCsvErrorCodes(struct soap *soap, struct ns1__returnCsvErrorCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnCsvErrorCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__returnCsvErrorCodes * SOAP_FMAC2 soap_instantiate_ns1__returnCsvErrorCodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnCsvErrorCodes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__returnCsvErrorCodes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__returnCsvErrorCodes);
		if (size)
			*size = sizeof(struct ns1__returnCsvErrorCodes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__returnCsvErrorCodes, n);
		if (size)
			*size = n * sizeof(struct ns1__returnCsvErrorCodes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__returnCsvErrorCodes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__returnCsvErrorCodes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__returnCsvErrorCodes %p -> %p\n", q, p));
	*(struct ns1__returnCsvErrorCodes*)p = *(struct ns1__returnCsvErrorCodes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__returnCsvErrorCodesResponse(struct soap *soap, struct ns1__returnCsvErrorCodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__returnCsvErrorCodesResponse(struct soap *soap, const struct ns1__returnCsvErrorCodesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnCsvErrorCodesResponse(struct soap *soap, const char *tag, int id, const struct ns1__returnCsvErrorCodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnCsvErrorCodesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__returnCsvErrorCodesResponse * SOAP_FMAC4 soap_in_ns1__returnCsvErrorCodesResponse(struct soap *soap, const char *tag, struct ns1__returnCsvErrorCodesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__returnCsvErrorCodesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnCsvErrorCodesResponse, sizeof(struct ns1__returnCsvErrorCodesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__returnCsvErrorCodesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__returnCsvErrorCodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnCsvErrorCodesResponse, 0, sizeof(struct ns1__returnCsvErrorCodesResponse), 0, soap_copy_ns1__returnCsvErrorCodesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__returnCsvErrorCodesResponse(struct soap *soap, const struct ns1__returnCsvErrorCodesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__returnCsvErrorCodesResponse);
	if (soap_out_ns1__returnCsvErrorCodesResponse(soap, tag?tag:"ns1:returnCsvErrorCodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__returnCsvErrorCodesResponse * SOAP_FMAC4 soap_get_ns1__returnCsvErrorCodesResponse(struct soap *soap, struct ns1__returnCsvErrorCodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnCsvErrorCodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__returnCsvErrorCodesResponse * SOAP_FMAC2 soap_instantiate_ns1__returnCsvErrorCodesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnCsvErrorCodesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__returnCsvErrorCodesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__returnCsvErrorCodesResponse);
		if (size)
			*size = sizeof(struct ns1__returnCsvErrorCodesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__returnCsvErrorCodesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__returnCsvErrorCodesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__returnCsvErrorCodesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__returnCsvErrorCodesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__returnCsvErrorCodesResponse %p -> %p\n", q, p));
	*(struct ns1__returnCsvErrorCodesResponse*)p = *(struct ns1__returnCsvErrorCodesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__returnErrorCodes(struct soap *soap, struct ns1__returnErrorCodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__returnErrorCodes(struct soap *soap, const struct ns1__returnErrorCodes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__returnErrorCodes(struct soap *soap, const char *tag, int id, const struct ns1__returnErrorCodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__returnErrorCodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__returnErrorCodes * SOAP_FMAC4 soap_in_ns1__returnErrorCodes(struct soap *soap, const char *tag, struct ns1__returnErrorCodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__returnErrorCodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__returnErrorCodes, sizeof(struct ns1__returnErrorCodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__returnErrorCodes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__returnErrorCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__returnErrorCodes, 0, sizeof(struct ns1__returnErrorCodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__returnErrorCodes(struct soap *soap, const struct ns1__returnErrorCodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__returnErrorCodes);
	if (soap_out_ns1__returnErrorCodes(soap, tag?tag:"ns1:returnErrorCodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__returnErrorCodes * SOAP_FMAC4 soap_get_ns1__returnErrorCodes(struct soap *soap, struct ns1__returnErrorCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__returnErrorCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__returnErrorCodes * SOAP_FMAC2 soap_instantiate_ns1__returnErrorCodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__returnErrorCodes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__returnErrorCodes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__returnErrorCodes);
		if (size)
			*size = sizeof(struct ns1__returnErrorCodes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__returnErrorCodes, n);
		if (size)
			*size = n * sizeof(struct ns1__returnErrorCodes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__returnErrorCodes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__returnErrorCodes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__returnErrorCodes %p -> %p\n", q, p));
	*(struct ns1__returnErrorCodes*)p = *(struct ns1__returnErrorCodes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deactivateTwoFactorAuthentication(struct soap *soap, struct ns1__deactivateTwoFactorAuthentication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->accountType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deactivateTwoFactorAuthentication(struct soap *soap, const struct ns1__deactivateTwoFactorAuthentication *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deactivateTwoFactorAuthentication(struct soap *soap, const char *tag, int id, const struct ns1__deactivateTwoFactorAuthentication *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deactivateTwoFactorAuthentication), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "accountType", -1, &a->accountType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deactivateTwoFactorAuthentication * SOAP_FMAC4 soap_in_ns1__deactivateTwoFactorAuthentication(struct soap *soap, const char *tag, struct ns1__deactivateTwoFactorAuthentication *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_accountType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deactivateTwoFactorAuthentication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deactivateTwoFactorAuthentication, sizeof(struct ns1__deactivateTwoFactorAuthentication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__deactivateTwoFactorAuthentication(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_accountType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "accountType", &a->accountType, "xsd:int"))
				{	soap_flag_accountType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deactivateTwoFactorAuthentication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deactivateTwoFactorAuthentication, 0, sizeof(struct ns1__deactivateTwoFactorAuthentication), 0, soap_copy_ns1__deactivateTwoFactorAuthentication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_accountType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deactivateTwoFactorAuthentication(struct soap *soap, const struct ns1__deactivateTwoFactorAuthentication *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deactivateTwoFactorAuthentication);
	if (soap_out_ns1__deactivateTwoFactorAuthentication(soap, tag?tag:"ns1:deactivateTwoFactorAuthentication", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deactivateTwoFactorAuthentication * SOAP_FMAC4 soap_get_ns1__deactivateTwoFactorAuthentication(struct soap *soap, struct ns1__deactivateTwoFactorAuthentication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deactivateTwoFactorAuthentication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deactivateTwoFactorAuthentication * SOAP_FMAC2 soap_instantiate_ns1__deactivateTwoFactorAuthentication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deactivateTwoFactorAuthentication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deactivateTwoFactorAuthentication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deactivateTwoFactorAuthentication);
		if (size)
			*size = sizeof(struct ns1__deactivateTwoFactorAuthentication);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deactivateTwoFactorAuthentication, n);
		if (size)
			*size = n * sizeof(struct ns1__deactivateTwoFactorAuthentication);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deactivateTwoFactorAuthentication*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deactivateTwoFactorAuthentication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deactivateTwoFactorAuthentication %p -> %p\n", q, p));
	*(struct ns1__deactivateTwoFactorAuthentication*)p = *(struct ns1__deactivateTwoFactorAuthentication*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, struct ns1__deactivateTwoFactorAuthenticationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, const struct ns1__deactivateTwoFactorAuthenticationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, const char *tag, int id, const struct ns1__deactivateTwoFactorAuthenticationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deactivateTwoFactorAuthenticationResponse * SOAP_FMAC4 soap_in_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, const char *tag, struct ns1__deactivateTwoFactorAuthenticationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deactivateTwoFactorAuthenticationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse, sizeof(struct ns1__deactivateTwoFactorAuthenticationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deactivateTwoFactorAuthenticationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deactivateTwoFactorAuthenticationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse, 0, sizeof(struct ns1__deactivateTwoFactorAuthenticationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, const struct ns1__deactivateTwoFactorAuthenticationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse);
	if (soap_out_ns1__deactivateTwoFactorAuthenticationResponse(soap, tag?tag:"ns1:deactivateTwoFactorAuthenticationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deactivateTwoFactorAuthenticationResponse * SOAP_FMAC4 soap_get_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, struct ns1__deactivateTwoFactorAuthenticationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deactivateTwoFactorAuthenticationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deactivateTwoFactorAuthenticationResponse * SOAP_FMAC2 soap_instantiate_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deactivateTwoFactorAuthenticationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deactivateTwoFactorAuthenticationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deactivateTwoFactorAuthenticationResponse);
		if (size)
			*size = sizeof(struct ns1__deactivateTwoFactorAuthenticationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deactivateTwoFactorAuthenticationResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deactivateTwoFactorAuthenticationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deactivateTwoFactorAuthenticationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deactivateTwoFactorAuthenticationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deactivateTwoFactorAuthenticationResponse %p -> %p\n", q, p));
	*(struct ns1__deactivateTwoFactorAuthenticationResponse*)p = *(struct ns1__deactivateTwoFactorAuthenticationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStudentCareer(struct soap *soap, struct ns1__getStudentCareer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStudentCareer(struct soap *soap, const struct ns1__getStudentCareer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStudentCareer(struct soap *soap, const char *tag, int id, const struct ns1__getStudentCareer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStudentCareer), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStudentCareer * SOAP_FMAC4 soap_in_ns1__getStudentCareer(struct soap *soap, const char *tag, struct ns1__getStudentCareer *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getStudentCareer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStudentCareer, sizeof(struct ns1__getStudentCareer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getStudentCareer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStudentCareer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStudentCareer, 0, sizeof(struct ns1__getStudentCareer), 0, soap_copy_ns1__getStudentCareer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStudentCareer(struct soap *soap, const struct ns1__getStudentCareer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getStudentCareer);
	if (soap_out_ns1__getStudentCareer(soap, tag?tag:"ns1:getStudentCareer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStudentCareer * SOAP_FMAC4 soap_get_ns1__getStudentCareer(struct soap *soap, struct ns1__getStudentCareer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStudentCareer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getStudentCareer * SOAP_FMAC2 soap_instantiate_ns1__getStudentCareer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStudentCareer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStudentCareer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStudentCareer);
		if (size)
			*size = sizeof(struct ns1__getStudentCareer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getStudentCareer, n);
		if (size)
			*size = n * sizeof(struct ns1__getStudentCareer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getStudentCareer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStudentCareer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getStudentCareer %p -> %p\n", q, p));
	*(struct ns1__getStudentCareer*)p = *(struct ns1__getStudentCareer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStudentCareerResponse(struct soap *soap, struct ns1__getStudentCareerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStudentCareerResponse(struct soap *soap, const struct ns1__getStudentCareerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStudentCareerResponse(struct soap *soap, const char *tag, int id, const struct ns1__getStudentCareerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStudentCareerResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStudentCareerResponse * SOAP_FMAC4 soap_in_ns1__getStudentCareerResponse(struct soap *soap, const char *tag, struct ns1__getStudentCareerResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getStudentCareerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStudentCareerResponse, sizeof(struct ns1__getStudentCareerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getStudentCareerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStudentCareerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStudentCareerResponse, 0, sizeof(struct ns1__getStudentCareerResponse), 0, soap_copy_ns1__getStudentCareerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStudentCareerResponse(struct soap *soap, const struct ns1__getStudentCareerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getStudentCareerResponse);
	if (soap_out_ns1__getStudentCareerResponse(soap, tag?tag:"ns1:getStudentCareerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStudentCareerResponse * SOAP_FMAC4 soap_get_ns1__getStudentCareerResponse(struct soap *soap, struct ns1__getStudentCareerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStudentCareerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getStudentCareerResponse * SOAP_FMAC2 soap_instantiate_ns1__getStudentCareerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStudentCareerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStudentCareerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStudentCareerResponse);
		if (size)
			*size = sizeof(struct ns1__getStudentCareerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getStudentCareerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getStudentCareerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getStudentCareerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStudentCareerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getStudentCareerResponse %p -> %p\n", q, p));
	*(struct ns1__getStudentCareerResponse*)p = *(struct ns1__getStudentCareerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveSignature(struct soap *soap, struct ns1__saveSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->accountType);
	soap_default_std__string(soap, &a->signature);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveSignature(struct soap *soap, const struct ns1__saveSignature *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveSignature(struct soap *soap, const char *tag, int id, const struct ns1__saveSignature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveSignature), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "accountType", -1, &a->accountType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "signature", -1, &a->signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveSignature * SOAP_FMAC4 soap_in_ns1__saveSignature(struct soap *soap, const char *tag, struct ns1__saveSignature *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_accountType = 1;
	size_t soap_flag_signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveSignature *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveSignature, sizeof(struct ns1__saveSignature), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveSignature(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_accountType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "accountType", &a->accountType, "xsd:int"))
				{	soap_flag_accountType--;
					continue;
				}
			if (soap_flag_signature && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "signature", &a->signature, "xsd:string"))
				{	soap_flag_signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveSignature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveSignature, 0, sizeof(struct ns1__saveSignature), 0, soap_copy_ns1__saveSignature);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_accountType > 0 || soap_flag_signature > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveSignature(struct soap *soap, const struct ns1__saveSignature *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveSignature);
	if (soap_out_ns1__saveSignature(soap, tag?tag:"ns1:saveSignature", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveSignature * SOAP_FMAC4 soap_get_ns1__saveSignature(struct soap *soap, struct ns1__saveSignature *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveSignature * SOAP_FMAC2 soap_instantiate_ns1__saveSignature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveSignature(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveSignature, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveSignature);
		if (size)
			*size = sizeof(struct ns1__saveSignature);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveSignature, n);
		if (size)
			*size = n * sizeof(struct ns1__saveSignature);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveSignature*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveSignature(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveSignature %p -> %p\n", q, p));
	*(struct ns1__saveSignature*)p = *(struct ns1__saveSignature*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveSignatureResponse(struct soap *soap, struct ns1__saveSignatureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveSignatureResponse(struct soap *soap, const struct ns1__saveSignatureResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveSignatureResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveSignatureResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveSignatureResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveSignatureResponse * SOAP_FMAC4 soap_in_ns1__saveSignatureResponse(struct soap *soap, const char *tag, struct ns1__saveSignatureResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveSignatureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveSignatureResponse, sizeof(struct ns1__saveSignatureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveSignatureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveSignatureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveSignatureResponse, 0, sizeof(struct ns1__saveSignatureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveSignatureResponse(struct soap *soap, const struct ns1__saveSignatureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveSignatureResponse);
	if (soap_out_ns1__saveSignatureResponse(soap, tag?tag:"ns1:saveSignatureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveSignatureResponse * SOAP_FMAC4 soap_get_ns1__saveSignatureResponse(struct soap *soap, struct ns1__saveSignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveSignatureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveSignatureResponse * SOAP_FMAC2 soap_instantiate_ns1__saveSignatureResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveSignatureResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveSignatureResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveSignatureResponse);
		if (size)
			*size = sizeof(struct ns1__saveSignatureResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveSignatureResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveSignatureResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveSignatureResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveSignatureResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveSignatureResponse %p -> %p\n", q, p));
	*(struct ns1__saveSignatureResponse*)p = *(struct ns1__saveSignatureResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserOfficialClass(struct soap *soap, struct ns1__getUserOfficialClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->date);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserOfficialClass(struct soap *soap, const struct ns1__getUserOfficialClass *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserOfficialClass(struct soap *soap, const char *tag, int id, const struct ns1__getUserOfficialClass *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserOfficialClass), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "date", -1, &a->date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserOfficialClass * SOAP_FMAC4 soap_in_ns1__getUserOfficialClass(struct soap *soap, const char *tag, struct ns1__getUserOfficialClass *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserOfficialClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserOfficialClass, sizeof(struct ns1__getUserOfficialClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserOfficialClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_date && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "date", &a->date, "xsd:string"))
				{	soap_flag_date--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserOfficialClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserOfficialClass, 0, sizeof(struct ns1__getUserOfficialClass), 0, soap_copy_ns1__getUserOfficialClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_date > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserOfficialClass(struct soap *soap, const struct ns1__getUserOfficialClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserOfficialClass);
	if (soap_out_ns1__getUserOfficialClass(soap, tag?tag:"ns1:getUserOfficialClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserOfficialClass * SOAP_FMAC4 soap_get_ns1__getUserOfficialClass(struct soap *soap, struct ns1__getUserOfficialClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserOfficialClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserOfficialClass * SOAP_FMAC2 soap_instantiate_ns1__getUserOfficialClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserOfficialClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserOfficialClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserOfficialClass);
		if (size)
			*size = sizeof(struct ns1__getUserOfficialClass);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserOfficialClass, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserOfficialClass);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserOfficialClass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserOfficialClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserOfficialClass %p -> %p\n", q, p));
	*(struct ns1__getUserOfficialClass*)p = *(struct ns1__getUserOfficialClass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserOfficialClassResponse(struct soap *soap, struct ns1__getUserOfficialClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserOfficialClassResponse(struct soap *soap, const struct ns1__getUserOfficialClassResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserOfficialClassResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserOfficialClassResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserOfficialClassResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserOfficialClassResponse * SOAP_FMAC4 soap_in_ns1__getUserOfficialClassResponse(struct soap *soap, const char *tag, struct ns1__getUserOfficialClassResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserOfficialClassResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserOfficialClassResponse, sizeof(struct ns1__getUserOfficialClassResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserOfficialClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserOfficialClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserOfficialClassResponse, 0, sizeof(struct ns1__getUserOfficialClassResponse), 0, soap_copy_ns1__getUserOfficialClassResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserOfficialClassResponse(struct soap *soap, const struct ns1__getUserOfficialClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserOfficialClassResponse);
	if (soap_out_ns1__getUserOfficialClassResponse(soap, tag?tag:"ns1:getUserOfficialClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserOfficialClassResponse * SOAP_FMAC4 soap_get_ns1__getUserOfficialClassResponse(struct soap *soap, struct ns1__getUserOfficialClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserOfficialClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserOfficialClassResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserOfficialClassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserOfficialClassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserOfficialClassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserOfficialClassResponse);
		if (size)
			*size = sizeof(struct ns1__getUserOfficialClassResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserOfficialClassResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserOfficialClassResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserOfficialClassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserOfficialClassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserOfficialClassResponse %p -> %p\n", q, p));
	*(struct ns1__getUserOfficialClassResponse*)p = *(struct ns1__getUserOfficialClassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetailsByUsername(struct soap *soap, struct ns1__getUserDetailsByUsername *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->username);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetailsByUsername(struct soap *soap, const struct ns1__getUserDetailsByUsername *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->username);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsByUsername(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetailsByUsername *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsByUsername), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &a->username, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetailsByUsername * SOAP_FMAC4 soap_in_ns1__getUserDetailsByUsername(struct soap *soap, const char *tag, struct ns1__getUserDetailsByUsername *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_username = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetailsByUsername *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsByUsername, sizeof(struct ns1__getUserDetailsByUsername), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetailsByUsername(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetailsByUsername *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsByUsername, 0, sizeof(struct ns1__getUserDetailsByUsername), 0, soap_copy_ns1__getUserDetailsByUsername);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_username > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetailsByUsername(struct soap *soap, const struct ns1__getUserDetailsByUsername *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsByUsername);
	if (soap_out_ns1__getUserDetailsByUsername(soap, tag?tag:"ns1:getUserDetailsByUsername", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetailsByUsername * SOAP_FMAC4 soap_get_ns1__getUserDetailsByUsername(struct soap *soap, struct ns1__getUserDetailsByUsername *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsByUsername(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetailsByUsername * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsByUsername(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsByUsername(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsByUsername, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetailsByUsername);
		if (size)
			*size = sizeof(struct ns1__getUserDetailsByUsername);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetailsByUsername, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetailsByUsername);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetailsByUsername*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsByUsername(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetailsByUsername %p -> %p\n", q, p));
	*(struct ns1__getUserDetailsByUsername*)p = *(struct ns1__getUserDetailsByUsername*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetailsByUsernameResponse(struct soap *soap, struct ns1__getUserDetailsByUsernameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetailsByUsernameResponse(struct soap *soap, const struct ns1__getUserDetailsByUsernameResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsByUsernameResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetailsByUsernameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsByUsernameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetailsByUsernameResponse * SOAP_FMAC4 soap_in_ns1__getUserDetailsByUsernameResponse(struct soap *soap, const char *tag, struct ns1__getUserDetailsByUsernameResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetailsByUsernameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsByUsernameResponse, sizeof(struct ns1__getUserDetailsByUsernameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetailsByUsernameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetailsByUsernameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsByUsernameResponse, 0, sizeof(struct ns1__getUserDetailsByUsernameResponse), 0, soap_copy_ns1__getUserDetailsByUsernameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetailsByUsernameResponse(struct soap *soap, const struct ns1__getUserDetailsByUsernameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsByUsernameResponse);
	if (soap_out_ns1__getUserDetailsByUsernameResponse(soap, tag?tag:"ns1:getUserDetailsByUsernameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetailsByUsernameResponse * SOAP_FMAC4 soap_get_ns1__getUserDetailsByUsernameResponse(struct soap *soap, struct ns1__getUserDetailsByUsernameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsByUsernameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetailsByUsernameResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsByUsernameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsByUsernameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsByUsernameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetailsByUsernameResponse);
		if (size)
			*size = sizeof(struct ns1__getUserDetailsByUsernameResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetailsByUsernameResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetailsByUsernameResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetailsByUsernameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsByUsernameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetailsByUsernameResponse %p -> %p\n", q, p));
	*(struct ns1__getUserDetailsByUsernameResponse*)p = *(struct ns1__getUserDetailsByUsernameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetailsByNumber(struct soap *soap, struct ns1__getUserDetailsByNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->number);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetailsByNumber(struct soap *soap, const struct ns1__getUserDetailsByNumber *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->number);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsByNumber(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetailsByNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsByNumber), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "number", -1, &a->number, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetailsByNumber * SOAP_FMAC4 soap_in_ns1__getUserDetailsByNumber(struct soap *soap, const char *tag, struct ns1__getUserDetailsByNumber *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_number = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetailsByNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsByNumber, sizeof(struct ns1__getUserDetailsByNumber), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetailsByNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_number && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "number", &a->number, "xsd:string"))
				{	soap_flag_number--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetailsByNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsByNumber, 0, sizeof(struct ns1__getUserDetailsByNumber), 0, soap_copy_ns1__getUserDetailsByNumber);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_number > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetailsByNumber(struct soap *soap, const struct ns1__getUserDetailsByNumber *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsByNumber);
	if (soap_out_ns1__getUserDetailsByNumber(soap, tag?tag:"ns1:getUserDetailsByNumber", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetailsByNumber * SOAP_FMAC4 soap_get_ns1__getUserDetailsByNumber(struct soap *soap, struct ns1__getUserDetailsByNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsByNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetailsByNumber * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsByNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsByNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsByNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetailsByNumber);
		if (size)
			*size = sizeof(struct ns1__getUserDetailsByNumber);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetailsByNumber, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetailsByNumber);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetailsByNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsByNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetailsByNumber %p -> %p\n", q, p));
	*(struct ns1__getUserDetailsByNumber*)p = *(struct ns1__getUserDetailsByNumber*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetailsByNumberResponse(struct soap *soap, struct ns1__getUserDetailsByNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetailsByNumberResponse(struct soap *soap, const struct ns1__getUserDetailsByNumberResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsByNumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetailsByNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsByNumberResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetailsByNumberResponse * SOAP_FMAC4 soap_in_ns1__getUserDetailsByNumberResponse(struct soap *soap, const char *tag, struct ns1__getUserDetailsByNumberResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetailsByNumberResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsByNumberResponse, sizeof(struct ns1__getUserDetailsByNumberResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetailsByNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetailsByNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsByNumberResponse, 0, sizeof(struct ns1__getUserDetailsByNumberResponse), 0, soap_copy_ns1__getUserDetailsByNumberResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetailsByNumberResponse(struct soap *soap, const struct ns1__getUserDetailsByNumberResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsByNumberResponse);
	if (soap_out_ns1__getUserDetailsByNumberResponse(soap, tag?tag:"ns1:getUserDetailsByNumberResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetailsByNumberResponse * SOAP_FMAC4 soap_get_ns1__getUserDetailsByNumberResponse(struct soap *soap, struct ns1__getUserDetailsByNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsByNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetailsByNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsByNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsByNumberResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsByNumberResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetailsByNumberResponse);
		if (size)
			*size = sizeof(struct ns1__getUserDetailsByNumberResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetailsByNumberResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetailsByNumberResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetailsByNumberResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsByNumberResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetailsByNumberResponse %p -> %p\n", q, p));
	*(struct ns1__getUserDetailsByNumberResponse*)p = *(struct ns1__getUserDetailsByNumberResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetails(struct soap *soap, struct ns1__getUserDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetails(struct soap *soap, const struct ns1__getUserDetails *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetails(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetails), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetails * SOAP_FMAC4 soap_in_ns1__getUserDetails(struct soap *soap, const char *tag, struct ns1__getUserDetails *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetails *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetails, sizeof(struct ns1__getUserDetails), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetails, 0, sizeof(struct ns1__getUserDetails), 0, soap_copy_ns1__getUserDetails);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetails(struct soap *soap, const struct ns1__getUserDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetails);
	if (soap_out_ns1__getUserDetails(soap, tag?tag:"ns1:getUserDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetails * SOAP_FMAC4 soap_get_ns1__getUserDetails(struct soap *soap, struct ns1__getUserDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetails * SOAP_FMAC2 soap_instantiate_ns1__getUserDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetails(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetails, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetails);
		if (size)
			*size = sizeof(struct ns1__getUserDetails);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetails, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetails);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetails*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetails(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetails %p -> %p\n", q, p));
	*(struct ns1__getUserDetails*)p = *(struct ns1__getUserDetails*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDetailsResponse(struct soap *soap, struct ns1__getUserDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDetailsResponse(struct soap *soap, const struct ns1__getUserDetailsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDetailsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserDetailsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDetailsResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDetailsResponse * SOAP_FMAC4 soap_in_ns1__getUserDetailsResponse(struct soap *soap, const char *tag, struct ns1__getUserDetailsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserDetailsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDetailsResponse, sizeof(struct ns1__getUserDetailsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDetailsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDetailsResponse, 0, sizeof(struct ns1__getUserDetailsResponse), 0, soap_copy_ns1__getUserDetailsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDetailsResponse(struct soap *soap, const struct ns1__getUserDetailsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserDetailsResponse);
	if (soap_out_ns1__getUserDetailsResponse(soap, tag?tag:"ns1:getUserDetailsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDetailsResponse * SOAP_FMAC4 soap_get_ns1__getUserDetailsResponse(struct soap *soap, struct ns1__getUserDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserDetailsResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserDetailsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserDetailsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserDetailsResponse);
		if (size)
			*size = sizeof(struct ns1__getUserDetailsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserDetailsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserDetailsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserDetailsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserDetailsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserDetailsResponse %p -> %p\n", q, p));
	*(struct ns1__getUserDetailsResponse*)p = *(struct ns1__getUserDetailsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAbsents(struct soap *soap, struct ns1__getAbsents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->schoolYear);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAbsents(struct soap *soap, const struct ns1__getAbsents *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->schoolYear);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAbsents(struct soap *soap, const char *tag, int id, const struct ns1__getAbsents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAbsents), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "schoolYear", -1, &a->schoolYear, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAbsents * SOAP_FMAC4 soap_in_ns1__getAbsents(struct soap *soap, const char *tag, struct ns1__getAbsents *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_schoolYear = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAbsents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAbsents, sizeof(struct ns1__getAbsents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAbsents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_schoolYear && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "schoolYear", &a->schoolYear, "xsd:string"))
				{	soap_flag_schoolYear--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAbsents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAbsents, 0, sizeof(struct ns1__getAbsents), 0, soap_copy_ns1__getAbsents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_schoolYear > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAbsents(struct soap *soap, const struct ns1__getAbsents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAbsents);
	if (soap_out_ns1__getAbsents(soap, tag?tag:"ns1:getAbsents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAbsents * SOAP_FMAC4 soap_get_ns1__getAbsents(struct soap *soap, struct ns1__getAbsents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAbsents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAbsents * SOAP_FMAC2 soap_instantiate_ns1__getAbsents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAbsents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAbsents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAbsents);
		if (size)
			*size = sizeof(struct ns1__getAbsents);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAbsents, n);
		if (size)
			*size = n * sizeof(struct ns1__getAbsents);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAbsents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAbsents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAbsents %p -> %p\n", q, p));
	*(struct ns1__getAbsents*)p = *(struct ns1__getAbsents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAbsentsResponse(struct soap *soap, struct ns1__getAbsentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAbsentsResponse(struct soap *soap, const struct ns1__getAbsentsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAbsentsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAbsentsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAbsentsResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAbsentsResponse * SOAP_FMAC4 soap_in_ns1__getAbsentsResponse(struct soap *soap, const char *tag, struct ns1__getAbsentsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAbsentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAbsentsResponse, sizeof(struct ns1__getAbsentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAbsentsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAbsentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAbsentsResponse, 0, sizeof(struct ns1__getAbsentsResponse), 0, soap_copy_ns1__getAbsentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAbsentsResponse(struct soap *soap, const struct ns1__getAbsentsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAbsentsResponse);
	if (soap_out_ns1__getAbsentsResponse(soap, tag?tag:"ns1:getAbsentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAbsentsResponse * SOAP_FMAC4 soap_get_ns1__getAbsentsResponse(struct soap *soap, struct ns1__getAbsentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAbsentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAbsentsResponse * SOAP_FMAC2 soap_instantiate_ns1__getAbsentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAbsentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAbsentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAbsentsResponse);
		if (size)
			*size = sizeof(struct ns1__getAbsentsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAbsentsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAbsentsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAbsentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAbsentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAbsentsResponse %p -> %p\n", q, p));
	*(struct ns1__getAbsentsResponse*)p = *(struct ns1__getAbsentsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAbsentsByDate(struct soap *soap, struct ns1__getAbsentsByDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->date);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAbsentsByDate(struct soap *soap, const struct ns1__getAbsentsByDate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAbsentsByDate(struct soap *soap, const char *tag, int id, const struct ns1__getAbsentsByDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAbsentsByDate), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "date", -1, &a->date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAbsentsByDate * SOAP_FMAC4 soap_in_ns1__getAbsentsByDate(struct soap *soap, const char *tag, struct ns1__getAbsentsByDate *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAbsentsByDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAbsentsByDate, sizeof(struct ns1__getAbsentsByDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAbsentsByDate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_date && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "date", &a->date, "xsd:string"))
				{	soap_flag_date--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAbsentsByDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAbsentsByDate, 0, sizeof(struct ns1__getAbsentsByDate), 0, soap_copy_ns1__getAbsentsByDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_date > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAbsentsByDate(struct soap *soap, const struct ns1__getAbsentsByDate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAbsentsByDate);
	if (soap_out_ns1__getAbsentsByDate(soap, tag?tag:"ns1:getAbsentsByDate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAbsentsByDate * SOAP_FMAC4 soap_get_ns1__getAbsentsByDate(struct soap *soap, struct ns1__getAbsentsByDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAbsentsByDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAbsentsByDate * SOAP_FMAC2 soap_instantiate_ns1__getAbsentsByDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAbsentsByDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAbsentsByDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAbsentsByDate);
		if (size)
			*size = sizeof(struct ns1__getAbsentsByDate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAbsentsByDate, n);
		if (size)
			*size = n * sizeof(struct ns1__getAbsentsByDate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAbsentsByDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAbsentsByDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAbsentsByDate %p -> %p\n", q, p));
	*(struct ns1__getAbsentsByDate*)p = *(struct ns1__getAbsentsByDate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAbsentsByDateResponse(struct soap *soap, struct ns1__getAbsentsByDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAbsentsByDateResponse(struct soap *soap, const struct ns1__getAbsentsByDateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAbsentsByDateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAbsentsByDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAbsentsByDateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAbsentsByDateResponse * SOAP_FMAC4 soap_in_ns1__getAbsentsByDateResponse(struct soap *soap, const char *tag, struct ns1__getAbsentsByDateResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAbsentsByDateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAbsentsByDateResponse, sizeof(struct ns1__getAbsentsByDateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAbsentsByDateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAbsentsByDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAbsentsByDateResponse, 0, sizeof(struct ns1__getAbsentsByDateResponse), 0, soap_copy_ns1__getAbsentsByDateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAbsentsByDateResponse(struct soap *soap, const struct ns1__getAbsentsByDateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAbsentsByDateResponse);
	if (soap_out_ns1__getAbsentsByDateResponse(soap, tag?tag:"ns1:getAbsentsByDateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAbsentsByDateResponse * SOAP_FMAC4 soap_get_ns1__getAbsentsByDateResponse(struct soap *soap, struct ns1__getAbsentsByDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAbsentsByDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAbsentsByDateResponse * SOAP_FMAC2 soap_instantiate_ns1__getAbsentsByDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAbsentsByDateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAbsentsByDateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAbsentsByDateResponse);
		if (size)
			*size = sizeof(struct ns1__getAbsentsByDateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAbsentsByDateResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAbsentsByDateResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAbsentsByDateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAbsentsByDateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAbsentsByDateResponse %p -> %p\n", q, p));
	*(struct ns1__getAbsentsByDateResponse*)p = *(struct ns1__getAbsentsByDateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassTeachers(struct soap *soap, struct ns1__getClassTeachers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_bool(soap, &a->getAllOwners);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassTeachers(struct soap *soap, const struct ns1__getClassTeachers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassTeachers(struct soap *soap, const char *tag, int id, const struct ns1__getClassTeachers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassTeachers), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_bool(soap, "getAllOwners", -1, &a->getAllOwners, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassTeachers * SOAP_FMAC4 soap_in_ns1__getClassTeachers(struct soap *soap, const char *tag, struct ns1__getClassTeachers *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_getAllOwners = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassTeachers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassTeachers, sizeof(struct ns1__getClassTeachers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getClassTeachers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_getAllOwners && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "getAllOwners", &a->getAllOwners, "xsd:boolean"))
				{	soap_flag_getAllOwners--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassTeachers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassTeachers, 0, sizeof(struct ns1__getClassTeachers), 0, soap_copy_ns1__getClassTeachers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_getAllOwners > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassTeachers(struct soap *soap, const struct ns1__getClassTeachers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassTeachers);
	if (soap_out_ns1__getClassTeachers(soap, tag?tag:"ns1:getClassTeachers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassTeachers * SOAP_FMAC4 soap_get_ns1__getClassTeachers(struct soap *soap, struct ns1__getClassTeachers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassTeachers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassTeachers * SOAP_FMAC2 soap_instantiate_ns1__getClassTeachers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassTeachers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassTeachers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassTeachers);
		if (size)
			*size = sizeof(struct ns1__getClassTeachers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassTeachers, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassTeachers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassTeachers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassTeachers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassTeachers %p -> %p\n", q, p));
	*(struct ns1__getClassTeachers*)p = *(struct ns1__getClassTeachers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassTeachersResponse(struct soap *soap, struct ns1__getClassTeachersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassTeachersResponse(struct soap *soap, const struct ns1__getClassTeachersResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassTeachersResponse(struct soap *soap, const char *tag, int id, const struct ns1__getClassTeachersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassTeachersResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassTeachersResponse * SOAP_FMAC4 soap_in_ns1__getClassTeachersResponse(struct soap *soap, const char *tag, struct ns1__getClassTeachersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassTeachersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassTeachersResponse, sizeof(struct ns1__getClassTeachersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getClassTeachersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassTeachersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassTeachersResponse, 0, sizeof(struct ns1__getClassTeachersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassTeachersResponse(struct soap *soap, const struct ns1__getClassTeachersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassTeachersResponse);
	if (soap_out_ns1__getClassTeachersResponse(soap, tag?tag:"ns1:getClassTeachersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassTeachersResponse * SOAP_FMAC4 soap_get_ns1__getClassTeachersResponse(struct soap *soap, struct ns1__getClassTeachersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassTeachersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassTeachersResponse * SOAP_FMAC2 soap_instantiate_ns1__getClassTeachersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassTeachersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassTeachersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassTeachersResponse);
		if (size)
			*size = sizeof(struct ns1__getClassTeachersResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassTeachersResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassTeachersResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassTeachersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassTeachersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassTeachersResponse %p -> %p\n", q, p));
	*(struct ns1__getClassTeachersResponse*)p = *(struct ns1__getClassTeachersResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__unregisterStudent(struct soap *soap, struct ns1__unregisterStudent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->officialDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__unregisterStudent(struct soap *soap, const struct ns1__unregisterStudent *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->officialDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unregisterStudent(struct soap *soap, const char *tag, int id, const struct ns1__unregisterStudent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unregisterStudent), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "officialDate", -1, &a->officialDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__unregisterStudent * SOAP_FMAC4 soap_in_ns1__unregisterStudent(struct soap *soap, const char *tag, struct ns1__unregisterStudent *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_officialDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__unregisterStudent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unregisterStudent, sizeof(struct ns1__unregisterStudent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__unregisterStudent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_officialDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "officialDate", &a->officialDate, "xsd:string"))
				{	soap_flag_officialDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__unregisterStudent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unregisterStudent, 0, sizeof(struct ns1__unregisterStudent), 0, soap_copy_ns1__unregisterStudent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_officialDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__unregisterStudent(struct soap *soap, const struct ns1__unregisterStudent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__unregisterStudent);
	if (soap_out_ns1__unregisterStudent(soap, tag?tag:"ns1:unregisterStudent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__unregisterStudent * SOAP_FMAC4 soap_get_ns1__unregisterStudent(struct soap *soap, struct ns1__unregisterStudent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unregisterStudent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__unregisterStudent * SOAP_FMAC2 soap_instantiate_ns1__unregisterStudent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unregisterStudent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unregisterStudent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__unregisterStudent);
		if (size)
			*size = sizeof(struct ns1__unregisterStudent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__unregisterStudent, n);
		if (size)
			*size = n * sizeof(struct ns1__unregisterStudent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__unregisterStudent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unregisterStudent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__unregisterStudent %p -> %p\n", q, p));
	*(struct ns1__unregisterStudent*)p = *(struct ns1__unregisterStudent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__unregisterStudentResponse(struct soap *soap, struct ns1__unregisterStudentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__unregisterStudentResponse(struct soap *soap, const struct ns1__unregisterStudentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unregisterStudentResponse(struct soap *soap, const char *tag, int id, const struct ns1__unregisterStudentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unregisterStudentResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__unregisterStudentResponse * SOAP_FMAC4 soap_in_ns1__unregisterStudentResponse(struct soap *soap, const char *tag, struct ns1__unregisterStudentResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__unregisterStudentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unregisterStudentResponse, sizeof(struct ns1__unregisterStudentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__unregisterStudentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__unregisterStudentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unregisterStudentResponse, 0, sizeof(struct ns1__unregisterStudentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__unregisterStudentResponse(struct soap *soap, const struct ns1__unregisterStudentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__unregisterStudentResponse);
	if (soap_out_ns1__unregisterStudentResponse(soap, tag?tag:"ns1:unregisterStudentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__unregisterStudentResponse * SOAP_FMAC4 soap_get_ns1__unregisterStudentResponse(struct soap *soap, struct ns1__unregisterStudentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unregisterStudentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__unregisterStudentResponse * SOAP_FMAC2 soap_instantiate_ns1__unregisterStudentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unregisterStudentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unregisterStudentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__unregisterStudentResponse);
		if (size)
			*size = sizeof(struct ns1__unregisterStudentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__unregisterStudentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__unregisterStudentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__unregisterStudentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unregisterStudentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__unregisterStudentResponse %p -> %p\n", q, p));
	*(struct ns1__unregisterStudentResponse*)p = *(struct ns1__unregisterStudentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, struct ns1__getSkoreClassTeacherCourseRelation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, const struct ns1__getSkoreClassTeacherCourseRelation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, const char *tag, int id, const struct ns1__getSkoreClassTeacherCourseRelation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSkoreClassTeacherCourseRelation * SOAP_FMAC4 soap_in_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, const char *tag, struct ns1__getSkoreClassTeacherCourseRelation *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSkoreClassTeacherCourseRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation, sizeof(struct ns1__getSkoreClassTeacherCourseRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getSkoreClassTeacherCourseRelation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSkoreClassTeacherCourseRelation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation, 0, sizeof(struct ns1__getSkoreClassTeacherCourseRelation), 0, soap_copy_ns1__getSkoreClassTeacherCourseRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, const struct ns1__getSkoreClassTeacherCourseRelation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation);
	if (soap_out_ns1__getSkoreClassTeacherCourseRelation(soap, tag?tag:"ns1:getSkoreClassTeacherCourseRelation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSkoreClassTeacherCourseRelation * SOAP_FMAC4 soap_get_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, struct ns1__getSkoreClassTeacherCourseRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSkoreClassTeacherCourseRelation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSkoreClassTeacherCourseRelation * SOAP_FMAC2 soap_instantiate_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSkoreClassTeacherCourseRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSkoreClassTeacherCourseRelation);
		if (size)
			*size = sizeof(struct ns1__getSkoreClassTeacherCourseRelation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getSkoreClassTeacherCourseRelation, n);
		if (size)
			*size = n * sizeof(struct ns1__getSkoreClassTeacherCourseRelation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getSkoreClassTeacherCourseRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSkoreClassTeacherCourseRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSkoreClassTeacherCourseRelation %p -> %p\n", q, p));
	*(struct ns1__getSkoreClassTeacherCourseRelation*)p = *(struct ns1__getSkoreClassTeacherCourseRelation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, struct ns1__getSkoreClassTeacherCourseRelationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, const struct ns1__getSkoreClassTeacherCourseRelationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, const char *tag, int id, const struct ns1__getSkoreClassTeacherCourseRelationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSkoreClassTeacherCourseRelationResponse * SOAP_FMAC4 soap_in_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, const char *tag, struct ns1__getSkoreClassTeacherCourseRelationResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSkoreClassTeacherCourseRelationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse, sizeof(struct ns1__getSkoreClassTeacherCourseRelationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getSkoreClassTeacherCourseRelationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSkoreClassTeacherCourseRelationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse, 0, sizeof(struct ns1__getSkoreClassTeacherCourseRelationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, const struct ns1__getSkoreClassTeacherCourseRelationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse);
	if (soap_out_ns1__getSkoreClassTeacherCourseRelationResponse(soap, tag?tag:"ns1:getSkoreClassTeacherCourseRelationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSkoreClassTeacherCourseRelationResponse * SOAP_FMAC4 soap_get_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, struct ns1__getSkoreClassTeacherCourseRelationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSkoreClassTeacherCourseRelationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSkoreClassTeacherCourseRelationResponse * SOAP_FMAC2 soap_instantiate_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSkoreClassTeacherCourseRelationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSkoreClassTeacherCourseRelationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSkoreClassTeacherCourseRelationResponse);
		if (size)
			*size = sizeof(struct ns1__getSkoreClassTeacherCourseRelationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getSkoreClassTeacherCourseRelationResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getSkoreClassTeacherCourseRelationResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getSkoreClassTeacherCourseRelationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSkoreClassTeacherCourseRelationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSkoreClassTeacherCourseRelationResponse %p -> %p\n", q, p));
	*(struct ns1__getSkoreClassTeacherCourseRelationResponse*)p = *(struct ns1__getSkoreClassTeacherCourseRelationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sendMsg(struct soap *soap, struct ns1__sendMsg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->title);
	soap_default_std__string(soap, &a->body);
	soap_default_std__string(soap, &a->senderIdentifier);
	soap_default_xsd__anyType(soap, &a->attachments);
	soap_default_int(soap, &a->coaccount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sendMsg(struct soap *soap, const struct ns1__sendMsg *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->title);
	soap_serialize_std__string(soap, &a->body);
	soap_serialize_std__string(soap, &a->senderIdentifier);
	soap_serialize_xsd__anyType(soap, &a->attachments);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendMsg(struct soap *soap, const char *tag, int id, const struct ns1__sendMsg *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendMsg), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_std__string(soap, "body", -1, &a->body, ""))
		return soap->error;
	if (soap_out_std__string(soap, "senderIdentifier", -1, &a->senderIdentifier, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "attachments", -1, &a->attachments, ""))
		return soap->error;
	if (soap_out_int(soap, "coaccount", -1, &a->coaccount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sendMsg * SOAP_FMAC4 soap_in_ns1__sendMsg(struct soap *soap, const char *tag, struct ns1__sendMsg *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_title = 1;
	size_t soap_flag_body = 1;
	size_t soap_flag_senderIdentifier = 1;
	size_t soap_flag_attachments = 1;
	size_t soap_flag_coaccount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sendMsg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendMsg, sizeof(struct ns1__sendMsg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__sendMsg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "body", &a->body, "xsd:string"))
				{	soap_flag_body--;
					continue;
				}
			if (soap_flag_senderIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "senderIdentifier", &a->senderIdentifier, "xsd:string"))
				{	soap_flag_senderIdentifier--;
					continue;
				}
			if (soap_flag_attachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "attachments", &a->attachments, "xsd:anyType"))
				{	soap_flag_attachments--;
					continue;
				}
			if (soap_flag_coaccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "coaccount", &a->coaccount, "xsd:int"))
				{	soap_flag_coaccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sendMsg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendMsg, 0, sizeof(struct ns1__sendMsg), 0, soap_copy_ns1__sendMsg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_title > 0 || soap_flag_body > 0 || soap_flag_senderIdentifier > 0 || soap_flag_attachments > 0 || soap_flag_coaccount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sendMsg(struct soap *soap, const struct ns1__sendMsg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sendMsg);
	if (soap_out_ns1__sendMsg(soap, tag?tag:"ns1:sendMsg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sendMsg * SOAP_FMAC4 soap_get_ns1__sendMsg(struct soap *soap, struct ns1__sendMsg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendMsg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__sendMsg * SOAP_FMAC2 soap_instantiate_ns1__sendMsg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendMsg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendMsg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__sendMsg);
		if (size)
			*size = sizeof(struct ns1__sendMsg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__sendMsg, n);
		if (size)
			*size = n * sizeof(struct ns1__sendMsg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__sendMsg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendMsg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__sendMsg %p -> %p\n", q, p));
	*(struct ns1__sendMsg*)p = *(struct ns1__sendMsg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sendMsgResponse(struct soap *soap, struct ns1__sendMsgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sendMsgResponse(struct soap *soap, const struct ns1__sendMsgResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendMsgResponse(struct soap *soap, const char *tag, int id, const struct ns1__sendMsgResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendMsgResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sendMsgResponse * SOAP_FMAC4 soap_in_ns1__sendMsgResponse(struct soap *soap, const char *tag, struct ns1__sendMsgResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sendMsgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendMsgResponse, sizeof(struct ns1__sendMsgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sendMsgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sendMsgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendMsgResponse, 0, sizeof(struct ns1__sendMsgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sendMsgResponse(struct soap *soap, const struct ns1__sendMsgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sendMsgResponse);
	if (soap_out_ns1__sendMsgResponse(soap, tag?tag:"ns1:sendMsgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sendMsgResponse * SOAP_FMAC4 soap_get_ns1__sendMsgResponse(struct soap *soap, struct ns1__sendMsgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendMsgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__sendMsgResponse * SOAP_FMAC2 soap_instantiate_ns1__sendMsgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendMsgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendMsgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__sendMsgResponse);
		if (size)
			*size = sizeof(struct ns1__sendMsgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__sendMsgResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__sendMsgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__sendMsgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendMsgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__sendMsgResponse %p -> %p\n", q, p));
	*(struct ns1__sendMsgResponse*)p = *(struct ns1__sendMsgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__savePassword(struct soap *soap, struct ns1__savePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->password);
	soap_default_int(soap, &a->accountType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__savePassword(struct soap *soap, const struct ns1__savePassword *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__savePassword(struct soap *soap, const char *tag, int id, const struct ns1__savePassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__savePassword), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "accountType", -1, &a->accountType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__savePassword * SOAP_FMAC4 soap_in_ns1__savePassword(struct soap *soap, const char *tag, struct ns1__savePassword *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_accountType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__savePassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__savePassword, sizeof(struct ns1__savePassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__savePassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_accountType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "accountType", &a->accountType, "xsd:int"))
				{	soap_flag_accountType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__savePassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__savePassword, 0, sizeof(struct ns1__savePassword), 0, soap_copy_ns1__savePassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_password > 0 || soap_flag_accountType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__savePassword(struct soap *soap, const struct ns1__savePassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__savePassword);
	if (soap_out_ns1__savePassword(soap, tag?tag:"ns1:savePassword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__savePassword * SOAP_FMAC4 soap_get_ns1__savePassword(struct soap *soap, struct ns1__savePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__savePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__savePassword * SOAP_FMAC2 soap_instantiate_ns1__savePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__savePassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__savePassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__savePassword);
		if (size)
			*size = sizeof(struct ns1__savePassword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__savePassword, n);
		if (size)
			*size = n * sizeof(struct ns1__savePassword);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__savePassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__savePassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__savePassword %p -> %p\n", q, p));
	*(struct ns1__savePassword*)p = *(struct ns1__savePassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__savePasswordResponse(struct soap *soap, struct ns1__savePasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__savePasswordResponse(struct soap *soap, const struct ns1__savePasswordResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__savePasswordResponse(struct soap *soap, const char *tag, int id, const struct ns1__savePasswordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__savePasswordResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__savePasswordResponse * SOAP_FMAC4 soap_in_ns1__savePasswordResponse(struct soap *soap, const char *tag, struct ns1__savePasswordResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__savePasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__savePasswordResponse, sizeof(struct ns1__savePasswordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__savePasswordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__savePasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__savePasswordResponse, 0, sizeof(struct ns1__savePasswordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__savePasswordResponse(struct soap *soap, const struct ns1__savePasswordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__savePasswordResponse);
	if (soap_out_ns1__savePasswordResponse(soap, tag?tag:"ns1:savePasswordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__savePasswordResponse * SOAP_FMAC4 soap_get_ns1__savePasswordResponse(struct soap *soap, struct ns1__savePasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__savePasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__savePasswordResponse * SOAP_FMAC2 soap_instantiate_ns1__savePasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__savePasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__savePasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__savePasswordResponse);
		if (size)
			*size = sizeof(struct ns1__savePasswordResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__savePasswordResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__savePasswordResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__savePasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__savePasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__savePasswordResponse %p -> %p\n", q, p));
	*(struct ns1__savePasswordResponse*)p = *(struct ns1__savePasswordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__forcePasswordReset(struct soap *soap, struct ns1__forcePasswordReset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->accountType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__forcePasswordReset(struct soap *soap, const struct ns1__forcePasswordReset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__forcePasswordReset(struct soap *soap, const char *tag, int id, const struct ns1__forcePasswordReset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__forcePasswordReset), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "accountType", -1, &a->accountType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__forcePasswordReset * SOAP_FMAC4 soap_in_ns1__forcePasswordReset(struct soap *soap, const char *tag, struct ns1__forcePasswordReset *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_accountType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__forcePasswordReset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__forcePasswordReset, sizeof(struct ns1__forcePasswordReset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__forcePasswordReset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_accountType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "accountType", &a->accountType, "xsd:int"))
				{	soap_flag_accountType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__forcePasswordReset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__forcePasswordReset, 0, sizeof(struct ns1__forcePasswordReset), 0, soap_copy_ns1__forcePasswordReset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_accountType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__forcePasswordReset(struct soap *soap, const struct ns1__forcePasswordReset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__forcePasswordReset);
	if (soap_out_ns1__forcePasswordReset(soap, tag?tag:"ns1:forcePasswordReset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forcePasswordReset * SOAP_FMAC4 soap_get_ns1__forcePasswordReset(struct soap *soap, struct ns1__forcePasswordReset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__forcePasswordReset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__forcePasswordReset * SOAP_FMAC2 soap_instantiate_ns1__forcePasswordReset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__forcePasswordReset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__forcePasswordReset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__forcePasswordReset);
		if (size)
			*size = sizeof(struct ns1__forcePasswordReset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__forcePasswordReset, n);
		if (size)
			*size = n * sizeof(struct ns1__forcePasswordReset);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__forcePasswordReset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__forcePasswordReset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__forcePasswordReset %p -> %p\n", q, p));
	*(struct ns1__forcePasswordReset*)p = *(struct ns1__forcePasswordReset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__forcePasswordResetResponse(struct soap *soap, struct ns1__forcePasswordResetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__forcePasswordResetResponse(struct soap *soap, const struct ns1__forcePasswordResetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__forcePasswordResetResponse(struct soap *soap, const char *tag, int id, const struct ns1__forcePasswordResetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__forcePasswordResetResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__forcePasswordResetResponse * SOAP_FMAC4 soap_in_ns1__forcePasswordResetResponse(struct soap *soap, const char *tag, struct ns1__forcePasswordResetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__forcePasswordResetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__forcePasswordResetResponse, sizeof(struct ns1__forcePasswordResetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__forcePasswordResetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__forcePasswordResetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__forcePasswordResetResponse, 0, sizeof(struct ns1__forcePasswordResetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__forcePasswordResetResponse(struct soap *soap, const struct ns1__forcePasswordResetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__forcePasswordResetResponse);
	if (soap_out_ns1__forcePasswordResetResponse(soap, tag?tag:"ns1:forcePasswordResetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__forcePasswordResetResponse * SOAP_FMAC4 soap_get_ns1__forcePasswordResetResponse(struct soap *soap, struct ns1__forcePasswordResetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__forcePasswordResetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__forcePasswordResetResponse * SOAP_FMAC2 soap_instantiate_ns1__forcePasswordResetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__forcePasswordResetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__forcePasswordResetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__forcePasswordResetResponse);
		if (size)
			*size = sizeof(struct ns1__forcePasswordResetResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__forcePasswordResetResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__forcePasswordResetResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__forcePasswordResetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__forcePasswordResetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__forcePasswordResetResponse %p -> %p\n", q, p));
	*(struct ns1__forcePasswordResetResponse*)p = *(struct ns1__forcePasswordResetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__replaceInum(struct soap *soap, struct ns1__replaceInum *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->oldInum);
	soap_default_std__string(soap, &a->newInum);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__replaceInum(struct soap *soap, const struct ns1__replaceInum *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->oldInum);
	soap_serialize_std__string(soap, &a->newInum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__replaceInum(struct soap *soap, const char *tag, int id, const struct ns1__replaceInum *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__replaceInum), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "oldInum", -1, &a->oldInum, ""))
		return soap->error;
	if (soap_out_std__string(soap, "newInum", -1, &a->newInum, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__replaceInum * SOAP_FMAC4 soap_in_ns1__replaceInum(struct soap *soap, const char *tag, struct ns1__replaceInum *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_oldInum = 1;
	size_t soap_flag_newInum = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__replaceInum *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__replaceInum, sizeof(struct ns1__replaceInum), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__replaceInum(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_oldInum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "oldInum", &a->oldInum, "xsd:string"))
				{	soap_flag_oldInum--;
					continue;
				}
			if (soap_flag_newInum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "newInum", &a->newInum, "xsd:string"))
				{	soap_flag_newInum--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__replaceInum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__replaceInum, 0, sizeof(struct ns1__replaceInum), 0, soap_copy_ns1__replaceInum);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_oldInum > 0 || soap_flag_newInum > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__replaceInum(struct soap *soap, const struct ns1__replaceInum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__replaceInum);
	if (soap_out_ns1__replaceInum(soap, tag?tag:"ns1:replaceInum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__replaceInum * SOAP_FMAC4 soap_get_ns1__replaceInum(struct soap *soap, struct ns1__replaceInum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__replaceInum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__replaceInum * SOAP_FMAC2 soap_instantiate_ns1__replaceInum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__replaceInum(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__replaceInum, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__replaceInum);
		if (size)
			*size = sizeof(struct ns1__replaceInum);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__replaceInum, n);
		if (size)
			*size = n * sizeof(struct ns1__replaceInum);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__replaceInum*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__replaceInum(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__replaceInum %p -> %p\n", q, p));
	*(struct ns1__replaceInum*)p = *(struct ns1__replaceInum*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__replaceInumResponse(struct soap *soap, struct ns1__replaceInumResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__replaceInumResponse(struct soap *soap, const struct ns1__replaceInumResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__replaceInumResponse(struct soap *soap, const char *tag, int id, const struct ns1__replaceInumResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__replaceInumResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__replaceInumResponse * SOAP_FMAC4 soap_in_ns1__replaceInumResponse(struct soap *soap, const char *tag, struct ns1__replaceInumResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__replaceInumResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__replaceInumResponse, sizeof(struct ns1__replaceInumResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__replaceInumResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__replaceInumResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__replaceInumResponse, 0, sizeof(struct ns1__replaceInumResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__replaceInumResponse(struct soap *soap, const struct ns1__replaceInumResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__replaceInumResponse);
	if (soap_out_ns1__replaceInumResponse(soap, tag?tag:"ns1:replaceInumResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__replaceInumResponse * SOAP_FMAC4 soap_get_ns1__replaceInumResponse(struct soap *soap, struct ns1__replaceInumResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__replaceInumResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__replaceInumResponse * SOAP_FMAC2 soap_instantiate_ns1__replaceInumResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__replaceInumResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__replaceInumResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__replaceInumResponse);
		if (size)
			*size = sizeof(struct ns1__replaceInumResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__replaceInumResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__replaceInumResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__replaceInumResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__replaceInumResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__replaceInumResponse %p -> %p\n", q, p));
	*(struct ns1__replaceInumResponse*)p = *(struct ns1__replaceInumResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAccountPhoto(struct soap *soap, struct ns1__getAccountPhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAccountPhoto(struct soap *soap, const struct ns1__getAccountPhoto *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccountPhoto(struct soap *soap, const char *tag, int id, const struct ns1__getAccountPhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccountPhoto), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAccountPhoto * SOAP_FMAC4 soap_in_ns1__getAccountPhoto(struct soap *soap, const char *tag, struct ns1__getAccountPhoto *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAccountPhoto *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccountPhoto, sizeof(struct ns1__getAccountPhoto), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAccountPhoto(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAccountPhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccountPhoto, 0, sizeof(struct ns1__getAccountPhoto), 0, soap_copy_ns1__getAccountPhoto);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAccountPhoto(struct soap *soap, const struct ns1__getAccountPhoto *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAccountPhoto);
	if (soap_out_ns1__getAccountPhoto(soap, tag?tag:"ns1:getAccountPhoto", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAccountPhoto * SOAP_FMAC4 soap_get_ns1__getAccountPhoto(struct soap *soap, struct ns1__getAccountPhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccountPhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAccountPhoto * SOAP_FMAC2 soap_instantiate_ns1__getAccountPhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccountPhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccountPhoto, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAccountPhoto);
		if (size)
			*size = sizeof(struct ns1__getAccountPhoto);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAccountPhoto, n);
		if (size)
			*size = n * sizeof(struct ns1__getAccountPhoto);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAccountPhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccountPhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAccountPhoto %p -> %p\n", q, p));
	*(struct ns1__getAccountPhoto*)p = *(struct ns1__getAccountPhoto*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAccountPhotoResponse(struct soap *soap, struct ns1__getAccountPhotoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAccountPhotoResponse(struct soap *soap, const struct ns1__getAccountPhotoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccountPhotoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAccountPhotoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccountPhotoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAccountPhotoResponse * SOAP_FMAC4 soap_in_ns1__getAccountPhotoResponse(struct soap *soap, const char *tag, struct ns1__getAccountPhotoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAccountPhotoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccountPhotoResponse, sizeof(struct ns1__getAccountPhotoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAccountPhotoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAccountPhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccountPhotoResponse, 0, sizeof(struct ns1__getAccountPhotoResponse), 0, soap_copy_ns1__getAccountPhotoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAccountPhotoResponse(struct soap *soap, const struct ns1__getAccountPhotoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAccountPhotoResponse);
	if (soap_out_ns1__getAccountPhotoResponse(soap, tag?tag:"ns1:getAccountPhotoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAccountPhotoResponse * SOAP_FMAC4 soap_get_ns1__getAccountPhotoResponse(struct soap *soap, struct ns1__getAccountPhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccountPhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAccountPhotoResponse * SOAP_FMAC2 soap_instantiate_ns1__getAccountPhotoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccountPhotoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccountPhotoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAccountPhotoResponse);
		if (size)
			*size = sizeof(struct ns1__getAccountPhotoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAccountPhotoResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAccountPhotoResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAccountPhotoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccountPhotoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAccountPhotoResponse %p -> %p\n", q, p));
	*(struct ns1__getAccountPhotoResponse*)p = *(struct ns1__getAccountPhotoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__setAccountPhoto(struct soap *soap, struct ns1__setAccountPhoto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->photo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__setAccountPhoto(struct soap *soap, const struct ns1__setAccountPhoto *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->photo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setAccountPhoto(struct soap *soap, const char *tag, int id, const struct ns1__setAccountPhoto *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setAccountPhoto), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "photo", -1, &a->photo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__setAccountPhoto * SOAP_FMAC4 soap_in_ns1__setAccountPhoto(struct soap *soap, const char *tag, struct ns1__setAccountPhoto *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_photo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__setAccountPhoto *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setAccountPhoto, sizeof(struct ns1__setAccountPhoto), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__setAccountPhoto(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_photo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "photo", &a->photo, "xsd:string"))
				{	soap_flag_photo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__setAccountPhoto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setAccountPhoto, 0, sizeof(struct ns1__setAccountPhoto), 0, soap_copy_ns1__setAccountPhoto);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_photo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__setAccountPhoto(struct soap *soap, const struct ns1__setAccountPhoto *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__setAccountPhoto);
	if (soap_out_ns1__setAccountPhoto(soap, tag?tag:"ns1:setAccountPhoto", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__setAccountPhoto * SOAP_FMAC4 soap_get_ns1__setAccountPhoto(struct soap *soap, struct ns1__setAccountPhoto *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setAccountPhoto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__setAccountPhoto * SOAP_FMAC2 soap_instantiate_ns1__setAccountPhoto(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setAccountPhoto(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setAccountPhoto, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__setAccountPhoto);
		if (size)
			*size = sizeof(struct ns1__setAccountPhoto);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__setAccountPhoto, n);
		if (size)
			*size = n * sizeof(struct ns1__setAccountPhoto);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__setAccountPhoto*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setAccountPhoto(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__setAccountPhoto %p -> %p\n", q, p));
	*(struct ns1__setAccountPhoto*)p = *(struct ns1__setAccountPhoto*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__setAccountPhotoResponse(struct soap *soap, struct ns1__setAccountPhotoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__setAccountPhotoResponse(struct soap *soap, const struct ns1__setAccountPhotoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setAccountPhotoResponse(struct soap *soap, const char *tag, int id, const struct ns1__setAccountPhotoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setAccountPhotoResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__setAccountPhotoResponse * SOAP_FMAC4 soap_in_ns1__setAccountPhotoResponse(struct soap *soap, const char *tag, struct ns1__setAccountPhotoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__setAccountPhotoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setAccountPhotoResponse, sizeof(struct ns1__setAccountPhotoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__setAccountPhotoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__setAccountPhotoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setAccountPhotoResponse, 0, sizeof(struct ns1__setAccountPhotoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__setAccountPhotoResponse(struct soap *soap, const struct ns1__setAccountPhotoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__setAccountPhotoResponse);
	if (soap_out_ns1__setAccountPhotoResponse(soap, tag?tag:"ns1:setAccountPhotoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__setAccountPhotoResponse * SOAP_FMAC4 soap_get_ns1__setAccountPhotoResponse(struct soap *soap, struct ns1__setAccountPhotoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setAccountPhotoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__setAccountPhotoResponse * SOAP_FMAC2 soap_instantiate_ns1__setAccountPhotoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setAccountPhotoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setAccountPhotoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__setAccountPhotoResponse);
		if (size)
			*size = sizeof(struct ns1__setAccountPhotoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__setAccountPhotoResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__setAccountPhotoResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__setAccountPhotoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setAccountPhotoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__setAccountPhotoResponse %p -> %p\n", q, p));
	*(struct ns1__setAccountPhotoResponse*)p = *(struct ns1__setAccountPhotoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__setAccountStatus(struct soap *soap, struct ns1__setAccountStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_xsd__anyType(soap, &a->accountStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__setAccountStatus(struct soap *soap, const struct ns1__setAccountStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_xsd__anyType(soap, &a->accountStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setAccountStatus(struct soap *soap, const char *tag, int id, const struct ns1__setAccountStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setAccountStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "accountStatus", -1, &a->accountStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__setAccountStatus * SOAP_FMAC4 soap_in_ns1__setAccountStatus(struct soap *soap, const char *tag, struct ns1__setAccountStatus *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_accountStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__setAccountStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setAccountStatus, sizeof(struct ns1__setAccountStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__setAccountStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_accountStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "accountStatus", &a->accountStatus, "xsd:anyType"))
				{	soap_flag_accountStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__setAccountStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setAccountStatus, 0, sizeof(struct ns1__setAccountStatus), 0, soap_copy_ns1__setAccountStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_accountStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__setAccountStatus(struct soap *soap, const struct ns1__setAccountStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__setAccountStatus);
	if (soap_out_ns1__setAccountStatus(soap, tag?tag:"ns1:setAccountStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__setAccountStatus * SOAP_FMAC4 soap_get_ns1__setAccountStatus(struct soap *soap, struct ns1__setAccountStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setAccountStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__setAccountStatus * SOAP_FMAC2 soap_instantiate_ns1__setAccountStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setAccountStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setAccountStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__setAccountStatus);
		if (size)
			*size = sizeof(struct ns1__setAccountStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__setAccountStatus, n);
		if (size)
			*size = n * sizeof(struct ns1__setAccountStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__setAccountStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setAccountStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__setAccountStatus %p -> %p\n", q, p));
	*(struct ns1__setAccountStatus*)p = *(struct ns1__setAccountStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__setAccountStatusResponse(struct soap *soap, struct ns1__setAccountStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__setAccountStatusResponse(struct soap *soap, const struct ns1__setAccountStatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setAccountStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__setAccountStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setAccountStatusResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__setAccountStatusResponse * SOAP_FMAC4 soap_in_ns1__setAccountStatusResponse(struct soap *soap, const char *tag, struct ns1__setAccountStatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__setAccountStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setAccountStatusResponse, sizeof(struct ns1__setAccountStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__setAccountStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__setAccountStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setAccountStatusResponse, 0, sizeof(struct ns1__setAccountStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__setAccountStatusResponse(struct soap *soap, const struct ns1__setAccountStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__setAccountStatusResponse);
	if (soap_out_ns1__setAccountStatusResponse(soap, tag?tag:"ns1:setAccountStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__setAccountStatusResponse * SOAP_FMAC4 soap_get_ns1__setAccountStatusResponse(struct soap *soap, struct ns1__setAccountStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setAccountStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__setAccountStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__setAccountStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setAccountStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setAccountStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__setAccountStatusResponse);
		if (size)
			*size = sizeof(struct ns1__setAccountStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__setAccountStatusResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__setAccountStatusResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__setAccountStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setAccountStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__setAccountStatusResponse %p -> %p\n", q, p));
	*(struct ns1__setAccountStatusResponse*)p = *(struct ns1__setAccountStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClassesAndGroups(struct soap *soap, struct ns1__saveUserToClassesAndGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->csvList);
	soap_default_int(soap, &a->keepOld);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClassesAndGroups(struct soap *soap, const struct ns1__saveUserToClassesAndGroups *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->csvList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClassesAndGroups(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClassesAndGroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClassesAndGroups), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "csvList", -1, &a->csvList, ""))
		return soap->error;
	if (soap_out_int(soap, "keepOld", -1, &a->keepOld, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClassesAndGroups * SOAP_FMAC4 soap_in_ns1__saveUserToClassesAndGroups(struct soap *soap, const char *tag, struct ns1__saveUserToClassesAndGroups *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_csvList = 1;
	size_t soap_flag_keepOld = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClassesAndGroups *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClassesAndGroups, sizeof(struct ns1__saveUserToClassesAndGroups), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClassesAndGroups(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_csvList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "csvList", &a->csvList, "xsd:string"))
				{	soap_flag_csvList--;
					continue;
				}
			if (soap_flag_keepOld && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "keepOld", &a->keepOld, "xsd:int"))
				{	soap_flag_keepOld--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClassesAndGroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClassesAndGroups, 0, sizeof(struct ns1__saveUserToClassesAndGroups), 0, soap_copy_ns1__saveUserToClassesAndGroups);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_csvList > 0 || soap_flag_keepOld > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClassesAndGroups(struct soap *soap, const struct ns1__saveUserToClassesAndGroups *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClassesAndGroups);
	if (soap_out_ns1__saveUserToClassesAndGroups(soap, tag?tag:"ns1:saveUserToClassesAndGroups", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClassesAndGroups * SOAP_FMAC4 soap_get_ns1__saveUserToClassesAndGroups(struct soap *soap, struct ns1__saveUserToClassesAndGroups *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClassesAndGroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClassesAndGroups * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClassesAndGroups(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClassesAndGroups(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClassesAndGroups, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClassesAndGroups);
		if (size)
			*size = sizeof(struct ns1__saveUserToClassesAndGroups);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClassesAndGroups, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClassesAndGroups);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClassesAndGroups*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClassesAndGroups(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClassesAndGroups %p -> %p\n", q, p));
	*(struct ns1__saveUserToClassesAndGroups*)p = *(struct ns1__saveUserToClassesAndGroups*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, struct ns1__saveUserToClassesAndGroupsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, const struct ns1__saveUserToClassesAndGroupsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClassesAndGroupsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClassesAndGroupsResponse * SOAP_FMAC4 soap_in_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, const char *tag, struct ns1__saveUserToClassesAndGroupsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClassesAndGroupsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse, sizeof(struct ns1__saveUserToClassesAndGroupsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClassesAndGroupsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClassesAndGroupsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse, 0, sizeof(struct ns1__saveUserToClassesAndGroupsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, const struct ns1__saveUserToClassesAndGroupsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse);
	if (soap_out_ns1__saveUserToClassesAndGroupsResponse(soap, tag?tag:"ns1:saveUserToClassesAndGroupsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClassesAndGroupsResponse * SOAP_FMAC4 soap_get_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, struct ns1__saveUserToClassesAndGroupsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClassesAndGroupsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClassesAndGroupsResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClassesAndGroupsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClassesAndGroupsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClassesAndGroupsResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserToClassesAndGroupsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClassesAndGroupsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClassesAndGroupsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClassesAndGroupsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClassesAndGroupsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClassesAndGroupsResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserToClassesAndGroupsResponse*)p = *(struct ns1__saveUserToClassesAndGroupsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClass(struct soap *soap, struct ns1__saveUserToClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->class_);
	soap_default_std__string(soap, &a->officialDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClass(struct soap *soap, const struct ns1__saveUserToClass *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->class_);
	soap_serialize_std__string(soap, &a->officialDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClass(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClass *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClass), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "class", -1, &a->class_, ""))
		return soap->error;
	if (soap_out_std__string(soap, "officialDate", -1, &a->officialDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClass * SOAP_FMAC4 soap_in_ns1__saveUserToClass(struct soap *soap, const char *tag, struct ns1__saveUserToClass *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_class_ = 1;
	size_t soap_flag_officialDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClass, sizeof(struct ns1__saveUserToClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_class_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class", &a->class_, "xsd:string"))
				{	soap_flag_class_--;
					continue;
				}
			if (soap_flag_officialDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "officialDate", &a->officialDate, "xsd:string"))
				{	soap_flag_officialDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClass, 0, sizeof(struct ns1__saveUserToClass), 0, soap_copy_ns1__saveUserToClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_class_ > 0 || soap_flag_officialDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClass(struct soap *soap, const struct ns1__saveUserToClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClass);
	if (soap_out_ns1__saveUserToClass(soap, tag?tag:"ns1:saveUserToClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClass * SOAP_FMAC4 soap_get_ns1__saveUserToClass(struct soap *soap, struct ns1__saveUserToClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClass * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClass);
		if (size)
			*size = sizeof(struct ns1__saveUserToClass);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClass, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClass);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClass %p -> %p\n", q, p));
	*(struct ns1__saveUserToClass*)p = *(struct ns1__saveUserToClass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClassResponse(struct soap *soap, struct ns1__saveUserToClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClassResponse(struct soap *soap, const struct ns1__saveUserToClassResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClassResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClassResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClassResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClassResponse * SOAP_FMAC4 soap_in_ns1__saveUserToClassResponse(struct soap *soap, const char *tag, struct ns1__saveUserToClassResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClassResponse, sizeof(struct ns1__saveUserToClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClassResponse, 0, sizeof(struct ns1__saveUserToClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClassResponse(struct soap *soap, const struct ns1__saveUserToClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClassResponse);
	if (soap_out_ns1__saveUserToClassResponse(soap, tag?tag:"ns1:saveUserToClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClassResponse * SOAP_FMAC4 soap_get_ns1__saveUserToClassResponse(struct soap *soap, struct ns1__saveUserToClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClassResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClassResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserToClassResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClassResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClassResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClassResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserToClassResponse*)p = *(struct ns1__saveUserToClassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeUserFromGroup(struct soap *soap, struct ns1__removeUserFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->class_);
	soap_default_std__string(soap, &a->officialDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeUserFromGroup(struct soap *soap, const struct ns1__removeUserFromGroup *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->class_);
	soap_serialize_std__string(soap, &a->officialDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeUserFromGroup(struct soap *soap, const char *tag, int id, const struct ns1__removeUserFromGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeUserFromGroup), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "class", -1, &a->class_, ""))
		return soap->error;
	if (soap_out_std__string(soap, "officialDate", -1, &a->officialDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeUserFromGroup * SOAP_FMAC4 soap_in_ns1__removeUserFromGroup(struct soap *soap, const char *tag, struct ns1__removeUserFromGroup *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_class_ = 1;
	size_t soap_flag_officialDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeUserFromGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeUserFromGroup, sizeof(struct ns1__removeUserFromGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__removeUserFromGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_class_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class", &a->class_, "xsd:string"))
				{	soap_flag_class_--;
					continue;
				}
			if (soap_flag_officialDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "officialDate", &a->officialDate, "xsd:string"))
				{	soap_flag_officialDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeUserFromGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeUserFromGroup, 0, sizeof(struct ns1__removeUserFromGroup), 0, soap_copy_ns1__removeUserFromGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_class_ > 0 || soap_flag_officialDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeUserFromGroup(struct soap *soap, const struct ns1__removeUserFromGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeUserFromGroup);
	if (soap_out_ns1__removeUserFromGroup(soap, tag?tag:"ns1:removeUserFromGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeUserFromGroup * SOAP_FMAC4 soap_get_ns1__removeUserFromGroup(struct soap *soap, struct ns1__removeUserFromGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeUserFromGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeUserFromGroup * SOAP_FMAC2 soap_instantiate_ns1__removeUserFromGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeUserFromGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeUserFromGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeUserFromGroup);
		if (size)
			*size = sizeof(struct ns1__removeUserFromGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__removeUserFromGroup, n);
		if (size)
			*size = n * sizeof(struct ns1__removeUserFromGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__removeUserFromGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeUserFromGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeUserFromGroup %p -> %p\n", q, p));
	*(struct ns1__removeUserFromGroup*)p = *(struct ns1__removeUserFromGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeUserFromGroupResponse(struct soap *soap, struct ns1__removeUserFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeUserFromGroupResponse(struct soap *soap, const struct ns1__removeUserFromGroupResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeUserFromGroupResponse(struct soap *soap, const char *tag, int id, const struct ns1__removeUserFromGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeUserFromGroupResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeUserFromGroupResponse * SOAP_FMAC4 soap_in_ns1__removeUserFromGroupResponse(struct soap *soap, const char *tag, struct ns1__removeUserFromGroupResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeUserFromGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeUserFromGroupResponse, sizeof(struct ns1__removeUserFromGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__removeUserFromGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeUserFromGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeUserFromGroupResponse, 0, sizeof(struct ns1__removeUserFromGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeUserFromGroupResponse(struct soap *soap, const struct ns1__removeUserFromGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeUserFromGroupResponse);
	if (soap_out_ns1__removeUserFromGroupResponse(soap, tag?tag:"ns1:removeUserFromGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeUserFromGroupResponse * SOAP_FMAC4 soap_get_ns1__removeUserFromGroupResponse(struct soap *soap, struct ns1__removeUserFromGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeUserFromGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeUserFromGroupResponse * SOAP_FMAC2 soap_instantiate_ns1__removeUserFromGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeUserFromGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeUserFromGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeUserFromGroupResponse);
		if (size)
			*size = sizeof(struct ns1__removeUserFromGroupResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__removeUserFromGroupResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__removeUserFromGroupResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__removeUserFromGroupResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeUserFromGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeUserFromGroupResponse %p -> %p\n", q, p));
	*(struct ns1__removeUserFromGroupResponse*)p = *(struct ns1__removeUserFromGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClasses(struct soap *soap, struct ns1__saveUserToClasses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->csvList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClasses(struct soap *soap, const struct ns1__saveUserToClasses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->csvList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClasses(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClasses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClasses), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "csvList", -1, &a->csvList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClasses * SOAP_FMAC4 soap_in_ns1__saveUserToClasses(struct soap *soap, const char *tag, struct ns1__saveUserToClasses *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_csvList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClasses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClasses, sizeof(struct ns1__saveUserToClasses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClasses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_csvList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "csvList", &a->csvList, "xsd:string"))
				{	soap_flag_csvList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClasses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClasses, 0, sizeof(struct ns1__saveUserToClasses), 0, soap_copy_ns1__saveUserToClasses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_csvList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClasses(struct soap *soap, const struct ns1__saveUserToClasses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClasses);
	if (soap_out_ns1__saveUserToClasses(soap, tag?tag:"ns1:saveUserToClasses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClasses * SOAP_FMAC4 soap_get_ns1__saveUserToClasses(struct soap *soap, struct ns1__saveUserToClasses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClasses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClasses * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClasses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClasses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClasses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClasses);
		if (size)
			*size = sizeof(struct ns1__saveUserToClasses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClasses, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClasses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClasses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClasses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClasses %p -> %p\n", q, p));
	*(struct ns1__saveUserToClasses*)p = *(struct ns1__saveUserToClasses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserToClassesResponse(struct soap *soap, struct ns1__saveUserToClassesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserToClassesResponse(struct soap *soap, const struct ns1__saveUserToClassesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserToClassesResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserToClassesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserToClassesResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserToClassesResponse * SOAP_FMAC4 soap_in_ns1__saveUserToClassesResponse(struct soap *soap, const char *tag, struct ns1__saveUserToClassesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserToClassesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserToClassesResponse, sizeof(struct ns1__saveUserToClassesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserToClassesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserToClassesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserToClassesResponse, 0, sizeof(struct ns1__saveUserToClassesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserToClassesResponse(struct soap *soap, const struct ns1__saveUserToClassesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserToClassesResponse);
	if (soap_out_ns1__saveUserToClassesResponse(soap, tag?tag:"ns1:saveUserToClassesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserToClassesResponse * SOAP_FMAC4 soap_get_ns1__saveUserToClassesResponse(struct soap *soap, struct ns1__saveUserToClassesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserToClassesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserToClassesResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserToClassesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserToClassesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserToClassesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserToClassesResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserToClassesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserToClassesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserToClassesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserToClassesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserToClassesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserToClassesResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserToClassesResponse*)p = *(struct ns1__saveUserToClassesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__delClass(struct soap *soap, struct ns1__delClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->code);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__delClass(struct soap *soap, const struct ns1__delClass *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->code);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delClass(struct soap *soap, const char *tag, int id, const struct ns1__delClass *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delClass), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__delClass * SOAP_FMAC4 soap_in_ns1__delClass(struct soap *soap, const char *tag, struct ns1__delClass *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_code = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__delClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delClass, sizeof(struct ns1__delClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__delClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__delClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delClass, 0, sizeof(struct ns1__delClass), 0, soap_copy_ns1__delClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_code > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__delClass(struct soap *soap, const struct ns1__delClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__delClass);
	if (soap_out_ns1__delClass(soap, tag?tag:"ns1:delClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__delClass * SOAP_FMAC4 soap_get_ns1__delClass(struct soap *soap, struct ns1__delClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__delClass * SOAP_FMAC2 soap_instantiate_ns1__delClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__delClass);
		if (size)
			*size = sizeof(struct ns1__delClass);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__delClass, n);
		if (size)
			*size = n * sizeof(struct ns1__delClass);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__delClass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__delClass %p -> %p\n", q, p));
	*(struct ns1__delClass*)p = *(struct ns1__delClass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__delClassResponse(struct soap *soap, struct ns1__delClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__delClassResponse(struct soap *soap, const struct ns1__delClassResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delClassResponse(struct soap *soap, const char *tag, int id, const struct ns1__delClassResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delClassResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__delClassResponse * SOAP_FMAC4 soap_in_ns1__delClassResponse(struct soap *soap, const char *tag, struct ns1__delClassResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__delClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delClassResponse, sizeof(struct ns1__delClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__delClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__delClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delClassResponse, 0, sizeof(struct ns1__delClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__delClassResponse(struct soap *soap, const struct ns1__delClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__delClassResponse);
	if (soap_out_ns1__delClassResponse(soap, tag?tag:"ns1:delClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__delClassResponse * SOAP_FMAC4 soap_get_ns1__delClassResponse(struct soap *soap, struct ns1__delClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__delClassResponse * SOAP_FMAC2 soap_instantiate_ns1__delClassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delClassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delClassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__delClassResponse);
		if (size)
			*size = sizeof(struct ns1__delClassResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__delClassResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__delClassResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__delClassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delClassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__delClassResponse %p -> %p\n", q, p));
	*(struct ns1__delClassResponse*)p = *(struct ns1__delClassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClassListJson(struct soap *soap, struct ns1__saveClassListJson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->jsonList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClassListJson(struct soap *soap, const struct ns1__saveClassListJson *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->jsonList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClassListJson(struct soap *soap, const char *tag, int id, const struct ns1__saveClassListJson *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClassListJson), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "jsonList", -1, &a->jsonList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClassListJson * SOAP_FMAC4 soap_in_ns1__saveClassListJson(struct soap *soap, const char *tag, struct ns1__saveClassListJson *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_jsonList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClassListJson *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClassListJson, sizeof(struct ns1__saveClassListJson), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveClassListJson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_jsonList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jsonList", &a->jsonList, "xsd:string"))
				{	soap_flag_jsonList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClassListJson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClassListJson, 0, sizeof(struct ns1__saveClassListJson), 0, soap_copy_ns1__saveClassListJson);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_jsonList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClassListJson(struct soap *soap, const struct ns1__saveClassListJson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClassListJson);
	if (soap_out_ns1__saveClassListJson(soap, tag?tag:"ns1:saveClassListJson", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClassListJson * SOAP_FMAC4 soap_get_ns1__saveClassListJson(struct soap *soap, struct ns1__saveClassListJson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClassListJson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClassListJson * SOAP_FMAC2 soap_instantiate_ns1__saveClassListJson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClassListJson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClassListJson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClassListJson);
		if (size)
			*size = sizeof(struct ns1__saveClassListJson);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClassListJson, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClassListJson);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClassListJson*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClassListJson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClassListJson %p -> %p\n", q, p));
	*(struct ns1__saveClassListJson*)p = *(struct ns1__saveClassListJson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClassListJsonResponse(struct soap *soap, struct ns1__saveClassListJsonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClassListJsonResponse(struct soap *soap, const struct ns1__saveClassListJsonResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClassListJsonResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveClassListJsonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClassListJsonResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClassListJsonResponse * SOAP_FMAC4 soap_in_ns1__saveClassListJsonResponse(struct soap *soap, const char *tag, struct ns1__saveClassListJsonResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClassListJsonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClassListJsonResponse, sizeof(struct ns1__saveClassListJsonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveClassListJsonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClassListJsonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClassListJsonResponse, 0, sizeof(struct ns1__saveClassListJsonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClassListJsonResponse(struct soap *soap, const struct ns1__saveClassListJsonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClassListJsonResponse);
	if (soap_out_ns1__saveClassListJsonResponse(soap, tag?tag:"ns1:saveClassListJsonResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClassListJsonResponse * SOAP_FMAC4 soap_get_ns1__saveClassListJsonResponse(struct soap *soap, struct ns1__saveClassListJsonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClassListJsonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClassListJsonResponse * SOAP_FMAC2 soap_instantiate_ns1__saveClassListJsonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClassListJsonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClassListJsonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClassListJsonResponse);
		if (size)
			*size = sizeof(struct ns1__saveClassListJsonResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClassListJsonResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClassListJsonResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClassListJsonResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClassListJsonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClassListJsonResponse %p -> %p\n", q, p));
	*(struct ns1__saveClassListJsonResponse*)p = *(struct ns1__saveClassListJsonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClassList(struct soap *soap, struct ns1__saveClassList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->serializedList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClassList(struct soap *soap, const struct ns1__saveClassList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->serializedList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClassList(struct soap *soap, const char *tag, int id, const struct ns1__saveClassList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClassList), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "serializedList", -1, &a->serializedList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClassList * SOAP_FMAC4 soap_in_ns1__saveClassList(struct soap *soap, const char *tag, struct ns1__saveClassList *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_serializedList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClassList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClassList, sizeof(struct ns1__saveClassList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveClassList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_serializedList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "serializedList", &a->serializedList, "xsd:string"))
				{	soap_flag_serializedList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClassList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClassList, 0, sizeof(struct ns1__saveClassList), 0, soap_copy_ns1__saveClassList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_serializedList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClassList(struct soap *soap, const struct ns1__saveClassList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClassList);
	if (soap_out_ns1__saveClassList(soap, tag?tag:"ns1:saveClassList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClassList * SOAP_FMAC4 soap_get_ns1__saveClassList(struct soap *soap, struct ns1__saveClassList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClassList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClassList * SOAP_FMAC2 soap_instantiate_ns1__saveClassList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClassList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClassList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClassList);
		if (size)
			*size = sizeof(struct ns1__saveClassList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClassList, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClassList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClassList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClassList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClassList %p -> %p\n", q, p));
	*(struct ns1__saveClassList*)p = *(struct ns1__saveClassList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClassListResponse(struct soap *soap, struct ns1__saveClassListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClassListResponse(struct soap *soap, const struct ns1__saveClassListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClassListResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveClassListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClassListResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClassListResponse * SOAP_FMAC4 soap_in_ns1__saveClassListResponse(struct soap *soap, const char *tag, struct ns1__saveClassListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClassListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClassListResponse, sizeof(struct ns1__saveClassListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveClassListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClassListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClassListResponse, 0, sizeof(struct ns1__saveClassListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClassListResponse(struct soap *soap, const struct ns1__saveClassListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClassListResponse);
	if (soap_out_ns1__saveClassListResponse(soap, tag?tag:"ns1:saveClassListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClassListResponse * SOAP_FMAC4 soap_get_ns1__saveClassListResponse(struct soap *soap, struct ns1__saveClassListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClassListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClassListResponse * SOAP_FMAC2 soap_instantiate_ns1__saveClassListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClassListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClassListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClassListResponse);
		if (size)
			*size = sizeof(struct ns1__saveClassListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClassListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClassListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClassListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClassListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClassListResponse %p -> %p\n", q, p));
	*(struct ns1__saveClassListResponse*)p = *(struct ns1__saveClassListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassListJson(struct soap *soap, struct ns1__getClassListJson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->accesscode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassListJson(struct soap *soap, const struct ns1__getClassListJson *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassListJson(struct soap *soap, const char *tag, int id, const struct ns1__getClassListJson *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassListJson), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassListJson * SOAP_FMAC4 soap_in_ns1__getClassListJson(struct soap *soap, const char *tag, struct ns1__getClassListJson *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassListJson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassListJson, sizeof(struct ns1__getClassListJson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getClassListJson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "accesscode", &a->accesscode, "xsd:anyType"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassListJson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassListJson, 0, sizeof(struct ns1__getClassListJson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassListJson(struct soap *soap, const struct ns1__getClassListJson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassListJson);
	if (soap_out_ns1__getClassListJson(soap, tag?tag:"ns1:getClassListJson", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassListJson * SOAP_FMAC4 soap_get_ns1__getClassListJson(struct soap *soap, struct ns1__getClassListJson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassListJson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassListJson * SOAP_FMAC2 soap_instantiate_ns1__getClassListJson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassListJson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassListJson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassListJson);
		if (size)
			*size = sizeof(struct ns1__getClassListJson);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassListJson, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassListJson);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassListJson*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassListJson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassListJson %p -> %p\n", q, p));
	*(struct ns1__getClassListJson*)p = *(struct ns1__getClassListJson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassListJsonResponse(struct soap *soap, struct ns1__getClassListJsonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassListJsonResponse(struct soap *soap, const struct ns1__getClassListJsonResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassListJsonResponse(struct soap *soap, const char *tag, int id, const struct ns1__getClassListJsonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassListJsonResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassListJsonResponse * SOAP_FMAC4 soap_in_ns1__getClassListJsonResponse(struct soap *soap, const char *tag, struct ns1__getClassListJsonResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassListJsonResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassListJsonResponse, sizeof(struct ns1__getClassListJsonResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getClassListJsonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassListJsonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassListJsonResponse, 0, sizeof(struct ns1__getClassListJsonResponse), 0, soap_copy_ns1__getClassListJsonResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassListJsonResponse(struct soap *soap, const struct ns1__getClassListJsonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassListJsonResponse);
	if (soap_out_ns1__getClassListJsonResponse(soap, tag?tag:"ns1:getClassListJsonResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassListJsonResponse * SOAP_FMAC4 soap_get_ns1__getClassListJsonResponse(struct soap *soap, struct ns1__getClassListJsonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassListJsonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassListJsonResponse * SOAP_FMAC2 soap_instantiate_ns1__getClassListJsonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassListJsonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassListJsonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassListJsonResponse);
		if (size)
			*size = sizeof(struct ns1__getClassListJsonResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassListJsonResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassListJsonResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassListJsonResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassListJsonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassListJsonResponse %p -> %p\n", q, p));
	*(struct ns1__getClassListJsonResponse*)p = *(struct ns1__getClassListJsonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassList(struct soap *soap, struct ns1__getClassList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->accesscode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassList(struct soap *soap, const struct ns1__getClassList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassList(struct soap *soap, const char *tag, int id, const struct ns1__getClassList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassList), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassList * SOAP_FMAC4 soap_in_ns1__getClassList(struct soap *soap, const char *tag, struct ns1__getClassList *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassList, sizeof(struct ns1__getClassList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getClassList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "accesscode", &a->accesscode, "xsd:anyType"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassList, 0, sizeof(struct ns1__getClassList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassList(struct soap *soap, const struct ns1__getClassList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassList);
	if (soap_out_ns1__getClassList(soap, tag?tag:"ns1:getClassList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassList * SOAP_FMAC4 soap_get_ns1__getClassList(struct soap *soap, struct ns1__getClassList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassList * SOAP_FMAC2 soap_instantiate_ns1__getClassList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassList);
		if (size)
			*size = sizeof(struct ns1__getClassList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassList, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassList %p -> %p\n", q, p));
	*(struct ns1__getClassList*)p = *(struct ns1__getClassList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getClassListResponse(struct soap *soap, struct ns1__getClassListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getClassListResponse(struct soap *soap, const struct ns1__getClassListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getClassListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getClassListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getClassListResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getClassListResponse * SOAP_FMAC4 soap_in_ns1__getClassListResponse(struct soap *soap, const char *tag, struct ns1__getClassListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getClassListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getClassListResponse, sizeof(struct ns1__getClassListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getClassListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getClassListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getClassListResponse, 0, sizeof(struct ns1__getClassListResponse), 0, soap_copy_ns1__getClassListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getClassListResponse(struct soap *soap, const struct ns1__getClassListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getClassListResponse);
	if (soap_out_ns1__getClassListResponse(soap, tag?tag:"ns1:getClassListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getClassListResponse * SOAP_FMAC4 soap_get_ns1__getClassListResponse(struct soap *soap, struct ns1__getClassListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getClassListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getClassListResponse * SOAP_FMAC2 soap_instantiate_ns1__getClassListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getClassListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getClassListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getClassListResponse);
		if (size)
			*size = sizeof(struct ns1__getClassListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getClassListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getClassListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getClassListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getClassListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getClassListResponse %p -> %p\n", q, p));
	*(struct ns1__getClassListResponse*)p = *(struct ns1__getClassListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserParameter(struct soap *soap, struct ns1__saveUserParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->paramName);
	soap_default_std__string(soap, &a->paramValue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserParameter(struct soap *soap, const struct ns1__saveUserParameter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->paramName);
	soap_serialize_std__string(soap, &a->paramValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserParameter(struct soap *soap, const char *tag, int id, const struct ns1__saveUserParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserParameter), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "paramName", -1, &a->paramName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "paramValue", -1, &a->paramValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserParameter * SOAP_FMAC4 soap_in_ns1__saveUserParameter(struct soap *soap, const char *tag, struct ns1__saveUserParameter *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_paramName = 1;
	size_t soap_flag_paramValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserParameter, sizeof(struct ns1__saveUserParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserParameter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_paramName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "paramName", &a->paramName, "xsd:string"))
				{	soap_flag_paramName--;
					continue;
				}
			if (soap_flag_paramValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "paramValue", &a->paramValue, "xsd:string"))
				{	soap_flag_paramValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserParameter, 0, sizeof(struct ns1__saveUserParameter), 0, soap_copy_ns1__saveUserParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_paramName > 0 || soap_flag_paramValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserParameter(struct soap *soap, const struct ns1__saveUserParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserParameter);
	if (soap_out_ns1__saveUserParameter(soap, tag?tag:"ns1:saveUserParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserParameter * SOAP_FMAC4 soap_get_ns1__saveUserParameter(struct soap *soap, struct ns1__saveUserParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserParameter * SOAP_FMAC2 soap_instantiate_ns1__saveUserParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserParameter);
		if (size)
			*size = sizeof(struct ns1__saveUserParameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserParameter, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserParameter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserParameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserParameter %p -> %p\n", q, p));
	*(struct ns1__saveUserParameter*)p = *(struct ns1__saveUserParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserParameterResponse(struct soap *soap, struct ns1__saveUserParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserParameterResponse(struct soap *soap, const struct ns1__saveUserParameterResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserParameterResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserParameterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserParameterResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserParameterResponse * SOAP_FMAC4 soap_in_ns1__saveUserParameterResponse(struct soap *soap, const char *tag, struct ns1__saveUserParameterResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserParameterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserParameterResponse, sizeof(struct ns1__saveUserParameterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserParameterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserParameterResponse, 0, sizeof(struct ns1__saveUserParameterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserParameterResponse(struct soap *soap, const struct ns1__saveUserParameterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserParameterResponse);
	if (soap_out_ns1__saveUserParameterResponse(soap, tag?tag:"ns1:saveUserParameterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserParameterResponse * SOAP_FMAC4 soap_get_ns1__saveUserParameterResponse(struct soap *soap, struct ns1__saveUserParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserParameterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserParameterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserParameterResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserParameterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserParameterResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserParameterResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserParameterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserParameterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserParameterResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserParameterResponse*)p = *(struct ns1__saveUserParameterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__delUser(struct soap *soap, struct ns1__delUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->userIdentifier);
	soap_default_std__string(soap, &a->officialDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__delUser(struct soap *soap, const struct ns1__delUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->userIdentifier);
	soap_serialize_std__string(soap, &a->officialDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delUser(struct soap *soap, const char *tag, int id, const struct ns1__delUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delUser), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_std__string(soap, "officialDate", -1, &a->officialDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__delUser * SOAP_FMAC4 soap_in_ns1__delUser(struct soap *soap, const char *tag, struct ns1__delUser *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_officialDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__delUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delUser, sizeof(struct ns1__delUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__delUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_officialDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "officialDate", &a->officialDate, "xsd:string"))
				{	soap_flag_officialDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__delUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delUser, 0, sizeof(struct ns1__delUser), 0, soap_copy_ns1__delUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_userIdentifier > 0 || soap_flag_officialDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__delUser(struct soap *soap, const struct ns1__delUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__delUser);
	if (soap_out_ns1__delUser(soap, tag?tag:"ns1:delUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__delUser * SOAP_FMAC4 soap_get_ns1__delUser(struct soap *soap, struct ns1__delUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__delUser * SOAP_FMAC2 soap_instantiate_ns1__delUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__delUser);
		if (size)
			*size = sizeof(struct ns1__delUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__delUser, n);
		if (size)
			*size = n * sizeof(struct ns1__delUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__delUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__delUser %p -> %p\n", q, p));
	*(struct ns1__delUser*)p = *(struct ns1__delUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__delUserResponse(struct soap *soap, struct ns1__delUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__delUserResponse(struct soap *soap, const struct ns1__delUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__delUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delUserResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__delUserResponse * SOAP_FMAC4 soap_in_ns1__delUserResponse(struct soap *soap, const char *tag, struct ns1__delUserResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__delUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delUserResponse, sizeof(struct ns1__delUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__delUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__delUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delUserResponse, 0, sizeof(struct ns1__delUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__delUserResponse(struct soap *soap, const struct ns1__delUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__delUserResponse);
	if (soap_out_ns1__delUserResponse(soap, tag?tag:"ns1:delUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__delUserResponse * SOAP_FMAC4 soap_get_ns1__delUserResponse(struct soap *soap, struct ns1__delUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__delUserResponse * SOAP_FMAC2 soap_instantiate_ns1__delUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__delUserResponse);
		if (size)
			*size = sizeof(struct ns1__delUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__delUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__delUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__delUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__delUserResponse %p -> %p\n", q, p));
	*(struct ns1__delUserResponse*)p = *(struct ns1__delUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCourses(struct soap *soap, struct ns1__getCourses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCourses(struct soap *soap, const struct ns1__getCourses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCourses(struct soap *soap, const char *tag, int id, const struct ns1__getCourses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCourses), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCourses * SOAP_FMAC4 soap_in_ns1__getCourses(struct soap *soap, const char *tag, struct ns1__getCourses *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCourses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCourses, sizeof(struct ns1__getCourses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getCourses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCourses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCourses, 0, sizeof(struct ns1__getCourses), 0, soap_copy_ns1__getCourses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCourses(struct soap *soap, const struct ns1__getCourses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCourses);
	if (soap_out_ns1__getCourses(soap, tag?tag:"ns1:getCourses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCourses * SOAP_FMAC4 soap_get_ns1__getCourses(struct soap *soap, struct ns1__getCourses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCourses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCourses * SOAP_FMAC2 soap_instantiate_ns1__getCourses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCourses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCourses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCourses);
		if (size)
			*size = sizeof(struct ns1__getCourses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCourses, n);
		if (size)
			*size = n * sizeof(struct ns1__getCourses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCourses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCourses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCourses %p -> %p\n", q, p));
	*(struct ns1__getCourses*)p = *(struct ns1__getCourses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCoursesResponse(struct soap *soap, struct ns1__getCoursesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCoursesResponse(struct soap *soap, const struct ns1__getCoursesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCoursesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCoursesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCoursesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCoursesResponse * SOAP_FMAC4 soap_in_ns1__getCoursesResponse(struct soap *soap, const char *tag, struct ns1__getCoursesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCoursesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCoursesResponse, sizeof(struct ns1__getCoursesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getCoursesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCoursesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCoursesResponse, 0, sizeof(struct ns1__getCoursesResponse), 0, soap_copy_ns1__getCoursesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCoursesResponse(struct soap *soap, const struct ns1__getCoursesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCoursesResponse);
	if (soap_out_ns1__getCoursesResponse(soap, tag?tag:"ns1:getCoursesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCoursesResponse * SOAP_FMAC4 soap_get_ns1__getCoursesResponse(struct soap *soap, struct ns1__getCoursesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCoursesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCoursesResponse * SOAP_FMAC2 soap_instantiate_ns1__getCoursesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCoursesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCoursesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCoursesResponse);
		if (size)
			*size = sizeof(struct ns1__getCoursesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCoursesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getCoursesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCoursesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCoursesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCoursesResponse %p -> %p\n", q, p));
	*(struct ns1__getCoursesResponse*)p = *(struct ns1__getCoursesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourseStudents(struct soap *soap, struct ns1__addCourseStudents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->coursename);
	soap_default_std__string(soap, &a->coursedesc);
	soap_default_std__string(soap, &a->groupIds);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourseStudents(struct soap *soap, const struct ns1__addCourseStudents *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->coursename);
	soap_serialize_std__string(soap, &a->coursedesc);
	soap_serialize_std__string(soap, &a->groupIds);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourseStudents(struct soap *soap, const char *tag, int id, const struct ns1__addCourseStudents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourseStudents), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursename", -1, &a->coursename, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursedesc", -1, &a->coursedesc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "groupIds", -1, &a->groupIds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourseStudents * SOAP_FMAC4 soap_in_ns1__addCourseStudents(struct soap *soap, const char *tag, struct ns1__addCourseStudents *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_coursename = 1;
	size_t soap_flag_coursedesc = 1;
	size_t soap_flag_groupIds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourseStudents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourseStudents, sizeof(struct ns1__addCourseStudents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__addCourseStudents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_coursename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursename", &a->coursename, "xsd:string"))
				{	soap_flag_coursename--;
					continue;
				}
			if (soap_flag_coursedesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursedesc", &a->coursedesc, "xsd:string"))
				{	soap_flag_coursedesc--;
					continue;
				}
			if (soap_flag_groupIds && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "groupIds", &a->groupIds, "xsd:string"))
				{	soap_flag_groupIds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourseStudents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourseStudents, 0, sizeof(struct ns1__addCourseStudents), 0, soap_copy_ns1__addCourseStudents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_coursename > 0 || soap_flag_coursedesc > 0 || soap_flag_groupIds > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourseStudents(struct soap *soap, const struct ns1__addCourseStudents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourseStudents);
	if (soap_out_ns1__addCourseStudents(soap, tag?tag:"ns1:addCourseStudents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourseStudents * SOAP_FMAC4 soap_get_ns1__addCourseStudents(struct soap *soap, struct ns1__addCourseStudents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourseStudents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourseStudents * SOAP_FMAC2 soap_instantiate_ns1__addCourseStudents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourseStudents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourseStudents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourseStudents);
		if (size)
			*size = sizeof(struct ns1__addCourseStudents);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourseStudents, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourseStudents);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourseStudents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourseStudents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourseStudents %p -> %p\n", q, p));
	*(struct ns1__addCourseStudents*)p = *(struct ns1__addCourseStudents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourseStudentsResponse(struct soap *soap, struct ns1__addCourseStudentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourseStudentsResponse(struct soap *soap, const struct ns1__addCourseStudentsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourseStudentsResponse(struct soap *soap, const char *tag, int id, const struct ns1__addCourseStudentsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourseStudentsResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourseStudentsResponse * SOAP_FMAC4 soap_in_ns1__addCourseStudentsResponse(struct soap *soap, const char *tag, struct ns1__addCourseStudentsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourseStudentsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourseStudentsResponse, sizeof(struct ns1__addCourseStudentsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addCourseStudentsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourseStudentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourseStudentsResponse, 0, sizeof(struct ns1__addCourseStudentsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourseStudentsResponse(struct soap *soap, const struct ns1__addCourseStudentsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourseStudentsResponse);
	if (soap_out_ns1__addCourseStudentsResponse(soap, tag?tag:"ns1:addCourseStudentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourseStudentsResponse * SOAP_FMAC4 soap_get_ns1__addCourseStudentsResponse(struct soap *soap, struct ns1__addCourseStudentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourseStudentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourseStudentsResponse * SOAP_FMAC2 soap_instantiate_ns1__addCourseStudentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourseStudentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourseStudentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourseStudentsResponse);
		if (size)
			*size = sizeof(struct ns1__addCourseStudentsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourseStudentsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourseStudentsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourseStudentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourseStudentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourseStudentsResponse %p -> %p\n", q, p));
	*(struct ns1__addCourseStudentsResponse*)p = *(struct ns1__addCourseStudentsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourseTeacher(struct soap *soap, struct ns1__addCourseTeacher *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->coursename);
	soap_default_std__string(soap, &a->coursedesc);
	soap_default_std__string(soap, &a->internnummer);
	soap_default_std__string(soap, &a->userlist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourseTeacher(struct soap *soap, const struct ns1__addCourseTeacher *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->coursename);
	soap_serialize_std__string(soap, &a->coursedesc);
	soap_serialize_std__string(soap, &a->internnummer);
	soap_serialize_std__string(soap, &a->userlist);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourseTeacher(struct soap *soap, const char *tag, int id, const struct ns1__addCourseTeacher *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourseTeacher), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursename", -1, &a->coursename, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursedesc", -1, &a->coursedesc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "internnummer", -1, &a->internnummer, ""))
		return soap->error;
	if (soap_out_std__string(soap, "userlist", -1, &a->userlist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourseTeacher * SOAP_FMAC4 soap_in_ns1__addCourseTeacher(struct soap *soap, const char *tag, struct ns1__addCourseTeacher *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_coursename = 1;
	size_t soap_flag_coursedesc = 1;
	size_t soap_flag_internnummer = 1;
	size_t soap_flag_userlist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourseTeacher *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourseTeacher, sizeof(struct ns1__addCourseTeacher), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__addCourseTeacher(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_coursename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursename", &a->coursename, "xsd:string"))
				{	soap_flag_coursename--;
					continue;
				}
			if (soap_flag_coursedesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursedesc", &a->coursedesc, "xsd:string"))
				{	soap_flag_coursedesc--;
					continue;
				}
			if (soap_flag_internnummer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "internnummer", &a->internnummer, "xsd:string"))
				{	soap_flag_internnummer--;
					continue;
				}
			if (soap_flag_userlist && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userlist", &a->userlist, "xsd:string"))
				{	soap_flag_userlist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourseTeacher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourseTeacher, 0, sizeof(struct ns1__addCourseTeacher), 0, soap_copy_ns1__addCourseTeacher);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_coursename > 0 || soap_flag_coursedesc > 0 || soap_flag_internnummer > 0 || soap_flag_userlist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourseTeacher(struct soap *soap, const struct ns1__addCourseTeacher *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourseTeacher);
	if (soap_out_ns1__addCourseTeacher(soap, tag?tag:"ns1:addCourseTeacher", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourseTeacher * SOAP_FMAC4 soap_get_ns1__addCourseTeacher(struct soap *soap, struct ns1__addCourseTeacher *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourseTeacher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourseTeacher * SOAP_FMAC2 soap_instantiate_ns1__addCourseTeacher(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourseTeacher(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourseTeacher, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourseTeacher);
		if (size)
			*size = sizeof(struct ns1__addCourseTeacher);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourseTeacher, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourseTeacher);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourseTeacher*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourseTeacher(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourseTeacher %p -> %p\n", q, p));
	*(struct ns1__addCourseTeacher*)p = *(struct ns1__addCourseTeacher*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourseTeacherResponse(struct soap *soap, struct ns1__addCourseTeacherResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourseTeacherResponse(struct soap *soap, const struct ns1__addCourseTeacherResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourseTeacherResponse(struct soap *soap, const char *tag, int id, const struct ns1__addCourseTeacherResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourseTeacherResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourseTeacherResponse * SOAP_FMAC4 soap_in_ns1__addCourseTeacherResponse(struct soap *soap, const char *tag, struct ns1__addCourseTeacherResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourseTeacherResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourseTeacherResponse, sizeof(struct ns1__addCourseTeacherResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addCourseTeacherResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourseTeacherResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourseTeacherResponse, 0, sizeof(struct ns1__addCourseTeacherResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourseTeacherResponse(struct soap *soap, const struct ns1__addCourseTeacherResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourseTeacherResponse);
	if (soap_out_ns1__addCourseTeacherResponse(soap, tag?tag:"ns1:addCourseTeacherResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourseTeacherResponse * SOAP_FMAC4 soap_get_ns1__addCourseTeacherResponse(struct soap *soap, struct ns1__addCourseTeacherResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourseTeacherResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourseTeacherResponse * SOAP_FMAC2 soap_instantiate_ns1__addCourseTeacherResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourseTeacherResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourseTeacherResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourseTeacherResponse);
		if (size)
			*size = sizeof(struct ns1__addCourseTeacherResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourseTeacherResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourseTeacherResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourseTeacherResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourseTeacherResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourseTeacherResponse %p -> %p\n", q, p));
	*(struct ns1__addCourseTeacherResponse*)p = *(struct ns1__addCourseTeacherResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourse(struct soap *soap, struct ns1__addCourse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->coursename);
	soap_default_std__string(soap, &a->coursedesc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourse(struct soap *soap, const struct ns1__addCourse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->coursename);
	soap_serialize_std__string(soap, &a->coursedesc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourse(struct soap *soap, const char *tag, int id, const struct ns1__addCourse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourse), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursename", -1, &a->coursename, ""))
		return soap->error;
	if (soap_out_std__string(soap, "coursedesc", -1, &a->coursedesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourse * SOAP_FMAC4 soap_in_ns1__addCourse(struct soap *soap, const char *tag, struct ns1__addCourse *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_coursename = 1;
	size_t soap_flag_coursedesc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourse, sizeof(struct ns1__addCourse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__addCourse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_coursename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursename", &a->coursename, "xsd:string"))
				{	soap_flag_coursename--;
					continue;
				}
			if (soap_flag_coursedesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "coursedesc", &a->coursedesc, "xsd:string"))
				{	soap_flag_coursedesc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourse, 0, sizeof(struct ns1__addCourse), 0, soap_copy_ns1__addCourse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_coursename > 0 || soap_flag_coursedesc > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourse(struct soap *soap, const struct ns1__addCourse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourse);
	if (soap_out_ns1__addCourse(soap, tag?tag:"ns1:addCourse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourse * SOAP_FMAC4 soap_get_ns1__addCourse(struct soap *soap, struct ns1__addCourse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourse * SOAP_FMAC2 soap_instantiate_ns1__addCourse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourse);
		if (size)
			*size = sizeof(struct ns1__addCourse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourse, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourse %p -> %p\n", q, p));
	*(struct ns1__addCourse*)p = *(struct ns1__addCourse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCourseResponse(struct soap *soap, struct ns1__addCourseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCourseResponse(struct soap *soap, const struct ns1__addCourseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCourseResponse(struct soap *soap, const char *tag, int id, const struct ns1__addCourseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCourseResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCourseResponse * SOAP_FMAC4 soap_in_ns1__addCourseResponse(struct soap *soap, const char *tag, struct ns1__addCourseResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCourseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCourseResponse, sizeof(struct ns1__addCourseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__addCourseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCourseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCourseResponse, 0, sizeof(struct ns1__addCourseResponse), 0, soap_copy_ns1__addCourseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCourseResponse(struct soap *soap, const struct ns1__addCourseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCourseResponse);
	if (soap_out_ns1__addCourseResponse(soap, tag?tag:"ns1:addCourseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCourseResponse * SOAP_FMAC4 soap_get_ns1__addCourseResponse(struct soap *soap, struct ns1__addCourseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCourseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCourseResponse * SOAP_FMAC2 soap_instantiate_ns1__addCourseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCourseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCourseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCourseResponse);
		if (size)
			*size = sizeof(struct ns1__addCourseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCourseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addCourseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCourseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCourseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCourseResponse %p -> %p\n", q, p));
	*(struct ns1__addCourseResponse*)p = *(struct ns1__addCourseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllGroupsAndClasses(struct soap *soap, struct ns1__getAllGroupsAndClasses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllGroupsAndClasses(struct soap *soap, const struct ns1__getAllGroupsAndClasses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllGroupsAndClasses(struct soap *soap, const char *tag, int id, const struct ns1__getAllGroupsAndClasses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllGroupsAndClasses), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllGroupsAndClasses * SOAP_FMAC4 soap_in_ns1__getAllGroupsAndClasses(struct soap *soap, const char *tag, struct ns1__getAllGroupsAndClasses *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllGroupsAndClasses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllGroupsAndClasses, sizeof(struct ns1__getAllGroupsAndClasses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAllGroupsAndClasses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllGroupsAndClasses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllGroupsAndClasses, 0, sizeof(struct ns1__getAllGroupsAndClasses), 0, soap_copy_ns1__getAllGroupsAndClasses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllGroupsAndClasses(struct soap *soap, const struct ns1__getAllGroupsAndClasses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllGroupsAndClasses);
	if (soap_out_ns1__getAllGroupsAndClasses(soap, tag?tag:"ns1:getAllGroupsAndClasses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllGroupsAndClasses * SOAP_FMAC4 soap_get_ns1__getAllGroupsAndClasses(struct soap *soap, struct ns1__getAllGroupsAndClasses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllGroupsAndClasses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllGroupsAndClasses * SOAP_FMAC2 soap_instantiate_ns1__getAllGroupsAndClasses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllGroupsAndClasses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllGroupsAndClasses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllGroupsAndClasses);
		if (size)
			*size = sizeof(struct ns1__getAllGroupsAndClasses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllGroupsAndClasses, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllGroupsAndClasses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllGroupsAndClasses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllGroupsAndClasses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllGroupsAndClasses %p -> %p\n", q, p));
	*(struct ns1__getAllGroupsAndClasses*)p = *(struct ns1__getAllGroupsAndClasses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllGroupsAndClassesResponse(struct soap *soap, struct ns1__getAllGroupsAndClassesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllGroupsAndClassesResponse(struct soap *soap, const struct ns1__getAllGroupsAndClassesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllGroupsAndClassesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAllGroupsAndClassesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllGroupsAndClassesResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllGroupsAndClassesResponse * SOAP_FMAC4 soap_in_ns1__getAllGroupsAndClassesResponse(struct soap *soap, const char *tag, struct ns1__getAllGroupsAndClassesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllGroupsAndClassesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllGroupsAndClassesResponse, sizeof(struct ns1__getAllGroupsAndClassesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAllGroupsAndClassesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllGroupsAndClassesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllGroupsAndClassesResponse, 0, sizeof(struct ns1__getAllGroupsAndClassesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllGroupsAndClassesResponse(struct soap *soap, const struct ns1__getAllGroupsAndClassesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllGroupsAndClassesResponse);
	if (soap_out_ns1__getAllGroupsAndClassesResponse(soap, tag?tag:"ns1:getAllGroupsAndClassesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllGroupsAndClassesResponse * SOAP_FMAC4 soap_get_ns1__getAllGroupsAndClassesResponse(struct soap *soap, struct ns1__getAllGroupsAndClassesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllGroupsAndClassesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllGroupsAndClassesResponse * SOAP_FMAC2 soap_instantiate_ns1__getAllGroupsAndClassesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllGroupsAndClassesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllGroupsAndClassesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllGroupsAndClassesResponse);
		if (size)
			*size = sizeof(struct ns1__getAllGroupsAndClassesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllGroupsAndClassesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllGroupsAndClassesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllGroupsAndClassesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllGroupsAndClassesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllGroupsAndClassesResponse %p -> %p\n", q, p));
	*(struct ns1__getAllGroupsAndClassesResponse*)p = *(struct ns1__getAllGroupsAndClassesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllAccountsExtended(struct soap *soap, struct ns1__getAllAccountsExtended *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->code);
	soap_default_std__string(soap, &a->recursive);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllAccountsExtended(struct soap *soap, const struct ns1__getAllAccountsExtended *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->code);
	soap_serialize_std__string(soap, &a->recursive);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllAccountsExtended(struct soap *soap, const char *tag, int id, const struct ns1__getAllAccountsExtended *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllAccountsExtended), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "recursive", -1, &a->recursive, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllAccountsExtended * SOAP_FMAC4 soap_in_ns1__getAllAccountsExtended(struct soap *soap, const char *tag, struct ns1__getAllAccountsExtended *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_code = 1;
	size_t soap_flag_recursive = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllAccountsExtended *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllAccountsExtended, sizeof(struct ns1__getAllAccountsExtended), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAllAccountsExtended(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_recursive && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "recursive", &a->recursive, "xsd:string"))
				{	soap_flag_recursive--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllAccountsExtended *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllAccountsExtended, 0, sizeof(struct ns1__getAllAccountsExtended), 0, soap_copy_ns1__getAllAccountsExtended);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_code > 0 || soap_flag_recursive > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllAccountsExtended(struct soap *soap, const struct ns1__getAllAccountsExtended *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllAccountsExtended);
	if (soap_out_ns1__getAllAccountsExtended(soap, tag?tag:"ns1:getAllAccountsExtended", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllAccountsExtended * SOAP_FMAC4 soap_get_ns1__getAllAccountsExtended(struct soap *soap, struct ns1__getAllAccountsExtended *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllAccountsExtended(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllAccountsExtended * SOAP_FMAC2 soap_instantiate_ns1__getAllAccountsExtended(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllAccountsExtended(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllAccountsExtended, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllAccountsExtended);
		if (size)
			*size = sizeof(struct ns1__getAllAccountsExtended);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllAccountsExtended, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllAccountsExtended);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllAccountsExtended*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllAccountsExtended(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllAccountsExtended %p -> %p\n", q, p));
	*(struct ns1__getAllAccountsExtended*)p = *(struct ns1__getAllAccountsExtended*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllAccountsExtendedResponse(struct soap *soap, struct ns1__getAllAccountsExtendedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllAccountsExtendedResponse(struct soap *soap, const struct ns1__getAllAccountsExtendedResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllAccountsExtendedResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAllAccountsExtendedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllAccountsExtendedResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllAccountsExtendedResponse * SOAP_FMAC4 soap_in_ns1__getAllAccountsExtendedResponse(struct soap *soap, const char *tag, struct ns1__getAllAccountsExtendedResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllAccountsExtendedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllAccountsExtendedResponse, sizeof(struct ns1__getAllAccountsExtendedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAllAccountsExtendedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllAccountsExtendedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllAccountsExtendedResponse, 0, sizeof(struct ns1__getAllAccountsExtendedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllAccountsExtendedResponse(struct soap *soap, const struct ns1__getAllAccountsExtendedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllAccountsExtendedResponse);
	if (soap_out_ns1__getAllAccountsExtendedResponse(soap, tag?tag:"ns1:getAllAccountsExtendedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllAccountsExtendedResponse * SOAP_FMAC4 soap_get_ns1__getAllAccountsExtendedResponse(struct soap *soap, struct ns1__getAllAccountsExtendedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllAccountsExtendedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllAccountsExtendedResponse * SOAP_FMAC2 soap_instantiate_ns1__getAllAccountsExtendedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllAccountsExtendedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllAccountsExtendedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllAccountsExtendedResponse);
		if (size)
			*size = sizeof(struct ns1__getAllAccountsExtendedResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllAccountsExtendedResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllAccountsExtendedResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllAccountsExtendedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllAccountsExtendedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllAccountsExtendedResponse %p -> %p\n", q, p));
	*(struct ns1__getAllAccountsExtendedResponse*)p = *(struct ns1__getAllAccountsExtendedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllAccounts(struct soap *soap, struct ns1__getAllAccounts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->code);
	soap_default_std__string(soap, &a->recursive);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllAccounts(struct soap *soap, const struct ns1__getAllAccounts *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->code);
	soap_serialize_std__string(soap, &a->recursive);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllAccounts(struct soap *soap, const char *tag, int id, const struct ns1__getAllAccounts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllAccounts), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "recursive", -1, &a->recursive, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllAccounts * SOAP_FMAC4 soap_in_ns1__getAllAccounts(struct soap *soap, const char *tag, struct ns1__getAllAccounts *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_code = 1;
	size_t soap_flag_recursive = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllAccounts *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllAccounts, sizeof(struct ns1__getAllAccounts), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAllAccounts(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_recursive && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "recursive", &a->recursive, "xsd:string"))
				{	soap_flag_recursive--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllAccounts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllAccounts, 0, sizeof(struct ns1__getAllAccounts), 0, soap_copy_ns1__getAllAccounts);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_code > 0 || soap_flag_recursive > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllAccounts(struct soap *soap, const struct ns1__getAllAccounts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllAccounts);
	if (soap_out_ns1__getAllAccounts(soap, tag?tag:"ns1:getAllAccounts", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllAccounts * SOAP_FMAC4 soap_get_ns1__getAllAccounts(struct soap *soap, struct ns1__getAllAccounts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllAccounts * SOAP_FMAC2 soap_instantiate_ns1__getAllAccounts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllAccounts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllAccounts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllAccounts);
		if (size)
			*size = sizeof(struct ns1__getAllAccounts);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllAccounts, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllAccounts);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllAccounts*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllAccounts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllAccounts %p -> %p\n", q, p));
	*(struct ns1__getAllAccounts*)p = *(struct ns1__getAllAccounts*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllAccountsResponse(struct soap *soap, struct ns1__getAllAccountsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllAccountsResponse(struct soap *soap, const struct ns1__getAllAccountsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllAccountsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAllAccountsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllAccountsResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllAccountsResponse * SOAP_FMAC4 soap_in_ns1__getAllAccountsResponse(struct soap *soap, const char *tag, struct ns1__getAllAccountsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllAccountsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllAccountsResponse, sizeof(struct ns1__getAllAccountsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAllAccountsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllAccountsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllAccountsResponse, 0, sizeof(struct ns1__getAllAccountsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllAccountsResponse(struct soap *soap, const struct ns1__getAllAccountsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllAccountsResponse);
	if (soap_out_ns1__getAllAccountsResponse(soap, tag?tag:"ns1:getAllAccountsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAllAccountsResponse * SOAP_FMAC4 soap_get_ns1__getAllAccountsResponse(struct soap *soap, struct ns1__getAllAccountsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllAccountsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAllAccountsResponse * SOAP_FMAC2 soap_instantiate_ns1__getAllAccountsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllAccountsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllAccountsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAllAccountsResponse);
		if (size)
			*size = sizeof(struct ns1__getAllAccountsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAllAccountsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAllAccountsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAllAccountsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllAccountsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllAccountsResponse %p -> %p\n", q, p));
	*(struct ns1__getAllAccountsResponse*)p = *(struct ns1__getAllAccountsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveGroup(struct soap *soap, struct ns1__saveGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->desc);
	soap_default_std__string(soap, &a->code);
	soap_default_std__string(soap, &a->parent);
	soap_default_std__string(soap, &a->untis);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveGroup(struct soap *soap, const struct ns1__saveGroup *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->name);
	soap_serialize_std__string(soap, &a->desc);
	soap_serialize_std__string(soap, &a->code);
	soap_serialize_std__string(soap, &a->parent);
	soap_serialize_std__string(soap, &a->untis);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveGroup(struct soap *soap, const char *tag, int id, const struct ns1__saveGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveGroup), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "parent", -1, &a->parent, ""))
		return soap->error;
	if (soap_out_std__string(soap, "untis", -1, &a->untis, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveGroup * SOAP_FMAC4 soap_in_ns1__saveGroup(struct soap *soap, const char *tag, struct ns1__saveGroup *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_code = 1;
	size_t soap_flag_parent = 1;
	size_t soap_flag_untis = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveGroup, sizeof(struct ns1__saveGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_parent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parent", &a->parent, "xsd:string"))
				{	soap_flag_parent--;
					continue;
				}
			if (soap_flag_untis && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "untis", &a->untis, "xsd:string"))
				{	soap_flag_untis--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveGroup, 0, sizeof(struct ns1__saveGroup), 0, soap_copy_ns1__saveGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_name > 0 || soap_flag_desc > 0 || soap_flag_code > 0 || soap_flag_parent > 0 || soap_flag_untis > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveGroup(struct soap *soap, const struct ns1__saveGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveGroup);
	if (soap_out_ns1__saveGroup(soap, tag?tag:"ns1:saveGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveGroup * SOAP_FMAC4 soap_get_ns1__saveGroup(struct soap *soap, struct ns1__saveGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveGroup * SOAP_FMAC2 soap_instantiate_ns1__saveGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveGroup);
		if (size)
			*size = sizeof(struct ns1__saveGroup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveGroup, n);
		if (size)
			*size = n * sizeof(struct ns1__saveGroup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveGroup %p -> %p\n", q, p));
	*(struct ns1__saveGroup*)p = *(struct ns1__saveGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveGroupResponse(struct soap *soap, struct ns1__saveGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveGroupResponse(struct soap *soap, const struct ns1__saveGroupResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveGroupResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveGroupResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveGroupResponse * SOAP_FMAC4 soap_in_ns1__saveGroupResponse(struct soap *soap, const char *tag, struct ns1__saveGroupResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveGroupResponse, sizeof(struct ns1__saveGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveGroupResponse, 0, sizeof(struct ns1__saveGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveGroupResponse(struct soap *soap, const struct ns1__saveGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveGroupResponse);
	if (soap_out_ns1__saveGroupResponse(soap, tag?tag:"ns1:saveGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveGroupResponse * SOAP_FMAC4 soap_get_ns1__saveGroupResponse(struct soap *soap, struct ns1__saveGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveGroupResponse * SOAP_FMAC2 soap_instantiate_ns1__saveGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveGroupResponse);
		if (size)
			*size = sizeof(struct ns1__saveGroupResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveGroupResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveGroupResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveGroupResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveGroupResponse %p -> %p\n", q, p));
	*(struct ns1__saveGroupResponse*)p = *(struct ns1__saveGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClass(struct soap *soap, struct ns1__saveClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->desc);
	soap_default_std__string(soap, &a->code);
	soap_default_std__string(soap, &a->parent);
	soap_default_std__string(soap, &a->untis);
	soap_default_std__string(soap, &a->instituteNumber);
	soap_default_std__string(soap, &a->adminNumber);
	soap_default_std__string(soap, &a->schoolYearDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClass(struct soap *soap, const struct ns1__saveClass *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->name);
	soap_serialize_std__string(soap, &a->desc);
	soap_serialize_std__string(soap, &a->code);
	soap_serialize_std__string(soap, &a->parent);
	soap_serialize_std__string(soap, &a->untis);
	soap_serialize_std__string(soap, &a->instituteNumber);
	soap_serialize_std__string(soap, &a->adminNumber);
	soap_serialize_std__string(soap, &a->schoolYearDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClass(struct soap *soap, const char *tag, int id, const struct ns1__saveClass *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClass), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "desc", -1, &a->desc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "parent", -1, &a->parent, ""))
		return soap->error;
	if (soap_out_std__string(soap, "untis", -1, &a->untis, ""))
		return soap->error;
	if (soap_out_std__string(soap, "instituteNumber", -1, &a->instituteNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "adminNumber", -1, &a->adminNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "schoolYearDate", -1, &a->schoolYearDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClass * SOAP_FMAC4 soap_in_ns1__saveClass(struct soap *soap, const char *tag, struct ns1__saveClass *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_desc = 1;
	size_t soap_flag_code = 1;
	size_t soap_flag_parent = 1;
	size_t soap_flag_untis = 1;
	size_t soap_flag_instituteNumber = 1;
	size_t soap_flag_adminNumber = 1;
	size_t soap_flag_schoolYearDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClass, sizeof(struct ns1__saveClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_parent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parent", &a->parent, "xsd:string"))
				{	soap_flag_parent--;
					continue;
				}
			if (soap_flag_untis && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "untis", &a->untis, "xsd:string"))
				{	soap_flag_untis--;
					continue;
				}
			if (soap_flag_instituteNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "instituteNumber", &a->instituteNumber, "xsd:string"))
				{	soap_flag_instituteNumber--;
					continue;
				}
			if (soap_flag_adminNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "adminNumber", &a->adminNumber, "xsd:string"))
				{	soap_flag_adminNumber--;
					continue;
				}
			if (soap_flag_schoolYearDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "schoolYearDate", &a->schoolYearDate, "xsd:string"))
				{	soap_flag_schoolYearDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClass, 0, sizeof(struct ns1__saveClass), 0, soap_copy_ns1__saveClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_name > 0 || soap_flag_desc > 0 || soap_flag_code > 0 || soap_flag_parent > 0 || soap_flag_untis > 0 || soap_flag_instituteNumber > 0 || soap_flag_adminNumber > 0 || soap_flag_schoolYearDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClass(struct soap *soap, const struct ns1__saveClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClass);
	if (soap_out_ns1__saveClass(soap, tag?tag:"ns1:saveClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClass * SOAP_FMAC4 soap_get_ns1__saveClass(struct soap *soap, struct ns1__saveClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClass * SOAP_FMAC2 soap_instantiate_ns1__saveClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClass);
		if (size)
			*size = sizeof(struct ns1__saveClass);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClass, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClass);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClass %p -> %p\n", q, p));
	*(struct ns1__saveClass*)p = *(struct ns1__saveClass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveClassResponse(struct soap *soap, struct ns1__saveClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveClassResponse(struct soap *soap, const struct ns1__saveClassResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveClassResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveClassResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveClassResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveClassResponse * SOAP_FMAC4 soap_in_ns1__saveClassResponse(struct soap *soap, const char *tag, struct ns1__saveClassResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveClassResponse, sizeof(struct ns1__saveClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveClassResponse, 0, sizeof(struct ns1__saveClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveClassResponse(struct soap *soap, const struct ns1__saveClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveClassResponse);
	if (soap_out_ns1__saveClassResponse(soap, tag?tag:"ns1:saveClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveClassResponse * SOAP_FMAC4 soap_get_ns1__saveClassResponse(struct soap *soap, struct ns1__saveClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveClassResponse * SOAP_FMAC2 soap_instantiate_ns1__saveClassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveClassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveClassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveClassResponse);
		if (size)
			*size = sizeof(struct ns1__saveClassResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveClassResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveClassResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveClassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveClassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveClassResponse %p -> %p\n", q, p));
	*(struct ns1__saveClassResponse*)p = *(struct ns1__saveClassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUser(struct soap *soap, struct ns1__saveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->accesscode);
	soap_default_std__string(soap, &a->internnumber);
	soap_default_std__string(soap, &a->username);
	soap_default_std__string(soap, &a->passwd1);
	soap_default_std__string(soap, &a->passwd2);
	soap_default_std__string(soap, &a->passwd3);
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->surname);
	soap_default_std__string(soap, &a->extranames);
	soap_default_std__string(soap, &a->initials);
	soap_default_std__string(soap, &a->sex);
	soap_default_std__string(soap, &a->birthday);
	soap_default_std__string(soap, &a->birthplace);
	soap_default_std__string(soap, &a->birthcountry);
	soap_default_std__string(soap, &a->address);
	soap_default_std__string(soap, &a->postalcode);
	soap_default_std__string(soap, &a->location);
	soap_default_std__string(soap, &a->country);
	soap_default_std__string(soap, &a->email);
	soap_default_std__string(soap, &a->mobilephone);
	soap_default_std__string(soap, &a->homephone);
	soap_default_std__string(soap, &a->fax);
	soap_default_std__string(soap, &a->prn);
	soap_default_std__string(soap, &a->stamboeknummer);
	soap_default_std__string(soap, &a->basisrol);
	soap_default_std__string(soap, &a->untis);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUser(struct soap *soap, const struct ns1__saveUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->accesscode);
	soap_serialize_std__string(soap, &a->internnumber);
	soap_serialize_std__string(soap, &a->username);
	soap_serialize_std__string(soap, &a->passwd1);
	soap_serialize_std__string(soap, &a->passwd2);
	soap_serialize_std__string(soap, &a->passwd3);
	soap_serialize_std__string(soap, &a->name);
	soap_serialize_std__string(soap, &a->surname);
	soap_serialize_std__string(soap, &a->extranames);
	soap_serialize_std__string(soap, &a->initials);
	soap_serialize_std__string(soap, &a->sex);
	soap_serialize_std__string(soap, &a->birthday);
	soap_serialize_std__string(soap, &a->birthplace);
	soap_serialize_std__string(soap, &a->birthcountry);
	soap_serialize_std__string(soap, &a->address);
	soap_serialize_std__string(soap, &a->postalcode);
	soap_serialize_std__string(soap, &a->location);
	soap_serialize_std__string(soap, &a->country);
	soap_serialize_std__string(soap, &a->email);
	soap_serialize_std__string(soap, &a->mobilephone);
	soap_serialize_std__string(soap, &a->homephone);
	soap_serialize_std__string(soap, &a->fax);
	soap_serialize_std__string(soap, &a->prn);
	soap_serialize_std__string(soap, &a->stamboeknummer);
	soap_serialize_std__string(soap, &a->basisrol);
	soap_serialize_std__string(soap, &a->untis);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUser(struct soap *soap, const char *tag, int id, const struct ns1__saveUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUser), type))
		return soap->error;
	if (soap_out_std__string(soap, "accesscode", -1, &a->accesscode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "internnumber", -1, &a->internnumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "passwd1", -1, &a->passwd1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "passwd2", -1, &a->passwd2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "passwd3", -1, &a->passwd3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "surname", -1, &a->surname, ""))
		return soap->error;
	if (soap_out_std__string(soap, "extranames", -1, &a->extranames, ""))
		return soap->error;
	if (soap_out_std__string(soap, "initials", -1, &a->initials, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sex", -1, &a->sex, ""))
		return soap->error;
	if (soap_out_std__string(soap, "birthday", -1, &a->birthday, ""))
		return soap->error;
	if (soap_out_std__string(soap, "birthplace", -1, &a->birthplace, ""))
		return soap->error;
	if (soap_out_std__string(soap, "birthcountry", -1, &a->birthcountry, ""))
		return soap->error;
	if (soap_out_std__string(soap, "address", -1, &a->address, ""))
		return soap->error;
	if (soap_out_std__string(soap, "postalcode", -1, &a->postalcode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "location", -1, &a->location, ""))
		return soap->error;
	if (soap_out_std__string(soap, "country", -1, &a->country, ""))
		return soap->error;
	if (soap_out_std__string(soap, "email", -1, &a->email, ""))
		return soap->error;
	if (soap_out_std__string(soap, "mobilephone", -1, &a->mobilephone, ""))
		return soap->error;
	if (soap_out_std__string(soap, "homephone", -1, &a->homephone, ""))
		return soap->error;
	if (soap_out_std__string(soap, "fax", -1, &a->fax, ""))
		return soap->error;
	if (soap_out_std__string(soap, "prn", -1, &a->prn, ""))
		return soap->error;
	if (soap_out_std__string(soap, "stamboeknummer", -1, &a->stamboeknummer, ""))
		return soap->error;
	if (soap_out_std__string(soap, "basisrol", -1, &a->basisrol, ""))
		return soap->error;
	if (soap_out_std__string(soap, "untis", -1, &a->untis, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUser * SOAP_FMAC4 soap_in_ns1__saveUser(struct soap *soap, const char *tag, struct ns1__saveUser *a, const char *type)
{
	size_t soap_flag_accesscode = 1;
	size_t soap_flag_internnumber = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_passwd1 = 1;
	size_t soap_flag_passwd2 = 1;
	size_t soap_flag_passwd3 = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_surname = 1;
	size_t soap_flag_extranames = 1;
	size_t soap_flag_initials = 1;
	size_t soap_flag_sex = 1;
	size_t soap_flag_birthday = 1;
	size_t soap_flag_birthplace = 1;
	size_t soap_flag_birthcountry = 1;
	size_t soap_flag_address = 1;
	size_t soap_flag_postalcode = 1;
	size_t soap_flag_location = 1;
	size_t soap_flag_country = 1;
	size_t soap_flag_email = 1;
	size_t soap_flag_mobilephone = 1;
	size_t soap_flag_homephone = 1;
	size_t soap_flag_fax = 1;
	size_t soap_flag_prn = 1;
	size_t soap_flag_stamboeknummer = 1;
	size_t soap_flag_basisrol = 1;
	size_t soap_flag_untis = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUser, sizeof(struct ns1__saveUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__saveUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accesscode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "accesscode", &a->accesscode, "xsd:string"))
				{	soap_flag_accesscode--;
					continue;
				}
			if (soap_flag_internnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "internnumber", &a->internnumber, "xsd:string"))
				{	soap_flag_internnumber--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_passwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "passwd1", &a->passwd1, "xsd:string"))
				{	soap_flag_passwd1--;
					continue;
				}
			if (soap_flag_passwd2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "passwd2", &a->passwd2, "xsd:string"))
				{	soap_flag_passwd2--;
					continue;
				}
			if (soap_flag_passwd3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "passwd3", &a->passwd3, "xsd:string"))
				{	soap_flag_passwd3--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_surname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "surname", &a->surname, "xsd:string"))
				{	soap_flag_surname--;
					continue;
				}
			if (soap_flag_extranames && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "extranames", &a->extranames, "xsd:string"))
				{	soap_flag_extranames--;
					continue;
				}
			if (soap_flag_initials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "initials", &a->initials, "xsd:string"))
				{	soap_flag_initials--;
					continue;
				}
			if (soap_flag_sex && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sex", &a->sex, "xsd:string"))
				{	soap_flag_sex--;
					continue;
				}
			if (soap_flag_birthday && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "birthday", &a->birthday, "xsd:string"))
				{	soap_flag_birthday--;
					continue;
				}
			if (soap_flag_birthplace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "birthplace", &a->birthplace, "xsd:string"))
				{	soap_flag_birthplace--;
					continue;
				}
			if (soap_flag_birthcountry && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "birthcountry", &a->birthcountry, "xsd:string"))
				{	soap_flag_birthcountry--;
					continue;
				}
			if (soap_flag_address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "address", &a->address, "xsd:string"))
				{	soap_flag_address--;
					continue;
				}
			if (soap_flag_postalcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "postalcode", &a->postalcode, "xsd:string"))
				{	soap_flag_postalcode--;
					continue;
				}
			if (soap_flag_location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "location", &a->location, "xsd:string"))
				{	soap_flag_location--;
					continue;
				}
			if (soap_flag_country && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "country", &a->country, "xsd:string"))
				{	soap_flag_country--;
					continue;
				}
			if (soap_flag_email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "email", &a->email, "xsd:string"))
				{	soap_flag_email--;
					continue;
				}
			if (soap_flag_mobilephone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mobilephone", &a->mobilephone, "xsd:string"))
				{	soap_flag_mobilephone--;
					continue;
				}
			if (soap_flag_homephone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "homephone", &a->homephone, "xsd:string"))
				{	soap_flag_homephone--;
					continue;
				}
			if (soap_flag_fax && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "fax", &a->fax, "xsd:string"))
				{	soap_flag_fax--;
					continue;
				}
			if (soap_flag_prn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "prn", &a->prn, "xsd:string"))
				{	soap_flag_prn--;
					continue;
				}
			if (soap_flag_stamboeknummer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "stamboeknummer", &a->stamboeknummer, "xsd:string"))
				{	soap_flag_stamboeknummer--;
					continue;
				}
			if (soap_flag_basisrol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "basisrol", &a->basisrol, "xsd:string"))
				{	soap_flag_basisrol--;
					continue;
				}
			if (soap_flag_untis && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "untis", &a->untis, "xsd:string"))
				{	soap_flag_untis--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUser, 0, sizeof(struct ns1__saveUser), 0, soap_copy_ns1__saveUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accesscode > 0 || soap_flag_internnumber > 0 || soap_flag_username > 0 || soap_flag_passwd1 > 0 || soap_flag_passwd2 > 0 || soap_flag_passwd3 > 0 || soap_flag_name > 0 || soap_flag_surname > 0 || soap_flag_extranames > 0 || soap_flag_initials > 0 || soap_flag_sex > 0 || soap_flag_birthday > 0 || soap_flag_birthplace > 0 || soap_flag_birthcountry > 0 || soap_flag_address > 0 || soap_flag_postalcode > 0 || soap_flag_location > 0 || soap_flag_country > 0 || soap_flag_email > 0 || soap_flag_mobilephone > 0 || soap_flag_homephone > 0 || soap_flag_fax > 0 || soap_flag_prn > 0 || soap_flag_stamboeknummer > 0 || soap_flag_basisrol > 0 || soap_flag_untis > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUser(struct soap *soap, const struct ns1__saveUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUser);
	if (soap_out_ns1__saveUser(soap, tag?tag:"ns1:saveUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUser * SOAP_FMAC4 soap_get_ns1__saveUser(struct soap *soap, struct ns1__saveUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUser * SOAP_FMAC2 soap_instantiate_ns1__saveUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUser);
		if (size)
			*size = sizeof(struct ns1__saveUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUser, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUser %p -> %p\n", q, p));
	*(struct ns1__saveUser*)p = *(struct ns1__saveUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserResponse(struct soap *soap, struct ns1__saveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserResponse(struct soap *soap, const struct ns1__saveUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserResponse), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserResponse * SOAP_FMAC4 soap_in_ns1__saveUserResponse(struct soap *soap, const char *tag, struct ns1__saveUserResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserResponse, sizeof(struct ns1__saveUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserResponse, 0, sizeof(struct ns1__saveUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserResponse(struct soap *soap, const struct ns1__saveUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserResponse);
	if (soap_out_ns1__saveUserResponse(soap, tag?tag:"ns1:saveUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserResponse * SOAP_FMAC4 soap_get_ns1__saveUserResponse(struct soap *soap, struct ns1__saveUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserResponse*)p = *(struct ns1__saveUserResponse*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag?tag:"xsd:anyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_attribute * SOAP_FMAC2 soap_instantiate_xsd__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute);
		if (size)
			*size = sizeof(struct soap_dom_attribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct soap_dom_attribute, n);
		if (size)
			*size = n * sizeof(struct soap_dom_attribute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct soap_dom_attribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_attribute %p -> %p\n", q, p));
	*(struct soap_dom_attribute*)p = *(struct soap_dom_attribute*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_element * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element);
		if (size)
			*size = sizeof(struct soap_dom_element);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct soap_dom_element, n);
		if (size)
			*size = n * sizeof(struct soap_dom_element);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct soap_dom_element*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_element %p -> %p\n", q, p));
	*(struct soap_dom_element*)p = *(struct soap_dom_element*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
